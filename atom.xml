<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>知秋</title>
  
  <subtitle>a little happy to share with you</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hqiwen.github.io/"/>
  <updated>2020-05-08T05:59:00.615Z</updated>
  <id>https://hqiwen.github.io/</id>
  
  <author>
    <name>贺启文</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>typescript变量声明</title>
    <link href="https://hqiwen.github.io/2020/05/08/typescript%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"/>
    <id>https://hqiwen.github.io/2020/05/08/typescript变量声明/</id>
    <published>2020-05-08T05:46:17.000Z</published>
    <updated>2020-05-08T05:59:00.615Z</updated>
    
    <content type="html"><![CDATA[<p>前一章我们写了一个相加程序，可以完成数字和数字的相加，也可以完成字符串和字符串的相加，根据第一个参数，提示第二个参数的类型。如果把一个数字和字符串相加，编译器就会报错，是不是很智能呢？细心的会发现声明了一个类型：<code>type operator = string | number;</code></p><blockquote><p>type是声明一个类型的关键字，不会新建一个类型，它创建了一个新名字来引用那个类型。</p></blockquote><p>这是我们完成类型检测的关键。下面我们来系统地学习typescript类型的奥秘，其中插入ES6语法的拓展。</p><h2 id="声明变量let、var、const"><a href="#声明变量let、var、const" class="headerlink" title="声明变量let、var、const"></a>声明变量let、var、const</h2><h3 id="var导致的声明提升"><a href="#var导致的声明提升" class="headerlink" title="var导致的声明提升"></a>var导致的声明提升</h3><p>在ES6之前的变量声明,var的使用,看看下面的道理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">// undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">// a = 1;</span></div><div class="line"><span class="built_in">console</span>.log(b);<span class="comment">//Uncaught ReferenceError: b is not defined,引用错误b没有被声明</span></div></pre></td></tr></table></figure><p>a和b打印出来的值不一样，为何？在javascript运行的过程中先会执行一遍预解析，使得变量a会被录入，但是没有执行赋值，故第一次打印a的值为undefined,赋值后打印a的值为1，变量b无声明，得到b is not defined。</p><h3 id="经典闭包问题的解决"><a href="#经典闭包问题的解决" class="headerlink" title="经典闭包问题的解决"></a>经典闭包问题的解决</h3><p>在JavaScript的面试中经常会碰到闭包问题，你能回答出下面的结果吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>答案是5个5，思考一下。<br><a id="more"></a><br>如果还弄不清为什么，先来看看定义：</p><blockquote><p>闭包：能够读取其他函数内部变量的函数，在JavaScript中，只有函数内部的子函数才可以读取局部变量</p></blockquote><p>在JavaScript中，有全局作用域和局部作用域之分。变量没有在函数内声明或者没有带var就是全局变量，拥有全局作用域，在代码任何地方都可以访问，如window是BOM提供的全局对象，在函数内部并且以var修饰的变量就是局部变量，只能在函数体内使用，函数的参数也是局部变量。</p><p>在<strong>全局作用域</strong>中存在着变量i,for循环5次添加了5个函数，在函数内部引用了变量i，所有函数均指向<strong>同一变量</strong>i，当循环结束后，变量i的值为5，此时执行console.log函数，打印出5个5。</p><p>闭包本质上将函数内部和函数外部连接起来的桥梁，例子中外部作用域的变量i被内部函数保存了起来。闭包常用来保护函数内的变量安全和在内存中维持一个变量，例子中的变量i被引用，得不到javascript垃圾收集机制的回收，容易造成内存泄露。</p><h3 id="块级作用域的引入"><a href="#块级作用域的引入" class="headerlink" title="块级作用域的引入"></a>块级作用域的引入</h3><p>let的出现使问题的得到了优雅的解决。只需要如下改动：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;, <span class="number">0</span>);</div><div class="line">&#125;<span class="comment">// 0,1,2,3,4</span></div></pre></td></tr></table></figure><p>没错，将var替换成let就可以解决问题。let在循环体内声明了五个<strong>局部变量</strong>，每次循环变量j都会被销毁，使得console.log函数读取到的值不同，打印出想要的结果。</p><h3 id="常量的不可变性"><a href="#常量的不可变性" class="headerlink" title="常量的不可变性"></a>常量的不可变性</h3><p>有时候我们需要一个全局变量，不可以被随意改动，这样就不会被破坏。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">3</span>;</div><div class="line">a = <span class="number">5</span>;<span class="comment">// Assignment to constant variable.对常量进行重复赋值。</span></div><div class="line"><span class="keyword">const</span> pai = <span class="number">3.1415</span></div></pre></td></tr></table></figure><p>如果有人尝试给const的变量赋值，就会得到编译器的警告。</p><h2 id="与JavaScript相通的类型"><a href="#与JavaScript相通的类型" class="headerlink" title="与JavaScript相通的类型"></a>与JavaScript相通的类型</h2><p>JavaScript有string、number、boolean、null、undefined、Symbol、Array、Function和Object 9种类型。Typescript提供了相应的类型。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>字符串是我们常接触的一种基础的类型，是有数字、字母、下划线组成的一串字符，是编程语言中表示<strong>文本</strong>的数据类型，和javascript一样，可以使用双引号（”）或单引号（’）表示字符串。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name:<span class="built_in">string</span> = <span class="string">"Alice"</span>;</div></pre></td></tr></table></figure><p>同时支持ES6的模板字符串，方便定义多行文本和内嵌表达式</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> weather: <span class="built_in">string</span> = <span class="string">"Sunny"</span>;</div><div class="line"><span class="keyword">let</span> today: <span class="built_in">string</span> = <span class="string">"Friday"</span>;</div><div class="line"><span class="keyword">let</span> reporter = <span class="string">`<span class="subst">$&#123;today&#125;</span> is <span class="subst">$&#123;weather&#125;</span>, have a nice day!:smile:`</span></div></pre></td></tr></table></figure><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 除了支持十进制和十六进制字面量，TypeScript还支持ES6中引入的二进制和八进制字面量。以下分别是10的各进制表示：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">10</span>;<span class="comment">/**十进制 */</span></div><div class="line"><span class="keyword">let</span> hexNum: <span class="built_in">number</span> = <span class="number">0x000a</span>;<span class="comment">/**十六进制 */</span></div><div class="line"><span class="keyword">let</span> binaryNum: <span class="built_in">number</span> = <span class="number">0b1010</span>;<span class="comment">/**二进制 */</span></div><div class="line"><span class="keyword">let</span> octNum:<span class="built_in">number</span> = <span class="number">0o012</span>;<span class="comment">/**八进制 */</span></div></pre></td></tr></table></figure><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>布尔值只有两个值true和false，常用于逻辑的判断，被各种语言支持。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> isFinished: <span class="built_in">boolean</span> = <span class="literal">false</span>;</div><div class="line"><span class="keyword">if</span>(isFinished) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"good,free to play!!"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"you need work hard!!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>数组是有序的元素序列，用于储存多个相同类型数据的集合。在typescript中有两种方式定义数组,与在JavaScript中的定义相差无几，只不过针对的是类型。</p><ul><li>间接法，在元素类型后面接[]，表示该类型的集合。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> height: <span class="built_in">number</span>[] = [<span class="number">155</span>, <span class="number">168</span>, <span class="number">177</span>];</div></pre></td></tr></table></figure><ul><li>直接法，在Array中注释类型，注意使用<strong>&lt;&gt;</strong>，又称数组泛型。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> height: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">155</span>, <span class="number">168</span>, <span class="number">177</span>];</div></pre></td></tr></table></figure><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><p>了解javaScript的人，对这两个一定不陌生。没有声明的变量使用时就是undefined，声明但是没有赋值就null，本身的类型用处不大。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</div></pre></td></tr></table></figure><p>默认情况下null和undefined是所有类型的子类型,可以被其他类型所接受。指定了<code>--strictNullChecks</code>标记时，null和undefined只能赋值给void和它们各自</p><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。由于函数很重要，将会拿出第四章专门介绍，这里简要提及。对函数的参数和函数返回类型进行描述。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"hello"</span> + msg;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>自ES6起，symbol成为了一种新的原生类型，就像number和string一样。symbol类型的值只能通过Symbol构造函数创建的，其值是不可改变和唯一的。关于symbol的细节不多讲，可以参考阮一峰的ES6教程。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> apple = Symbol(<span class="string">"fruit"</span>);</div><div class="line"><span class="keyword">let</span> orange = Symbol(<span class="string">"fruit"</span>)</div><div class="line">apple == orange<span class="comment">//false</span></div></pre></td></tr></table></figure><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。使用object类型，就可以更好的表示像Object.create这样的API。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="title">void</span></span>;</div><div class="line"></div><div class="line">create(&#123; prop: <span class="number">0</span> &#125;); <span class="comment">// OK</span></div><div class="line">create(<span class="literal">null</span>); <span class="comment">// OK</span></div><div class="line"></div><div class="line">create(<span class="number">42</span>); <span class="comment">// Error</span></div><div class="line">create(<span class="string">"string"</span>); <span class="comment">// Error</span></div><div class="line">create(<span class="literal">false</span>); <span class="comment">// Error</span></div><div class="line">create(<span class="literal">undefined</span>); <span class="comment">// Error</span></div></pre></td></tr></table></figure><h2 id="typescript特有的类型"><a href="#typescript特有的类型" class="headerlink" title="typescript特有的类型"></a>typescript特有的类型</h2><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>当我们无法再编译阶段弄清楚一个变量的类型时，可以用<code>any</code>类型来描述这些变量。在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> box : <span class="built_in">any</span> =  <span class="string">"black"</span>;</div><div class="line">box = <span class="number">4</span>;</div><div class="line">box = [<span class="string">"red"</span>, <span class="string">"black"</span>];</div></pre></td></tr></table></figure><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p><code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。常用来表示函数没有返回值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"This is my warning message"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元祖类型可以表示一个已知元素数量和类型的数组,是描述数组<strong>内部变量</strong>的一种类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> name = <span class="built_in">string</span>;</div><div class="line"><span class="keyword">type</span> age = <span class="built_in">number</span>;</div><div class="line"><span class="comment">//定义类型</span></div><div class="line"><span class="keyword">let</span> student: [name, age];</div><div class="line"><span class="comment">//初始化类型</span></div><div class="line">student = [<span class="string">"tom"</span>, <span class="number">14</span>]</div><div class="line"><span class="built_in">console</span>.log(student[<span class="number">0</span>]);<span class="comment">//"tom"</span></div><div class="line"><span class="built_in">console</span>.log(student[<span class="number">1</span>]);<span class="comment">//14</span></div></pre></td></tr></table></figure><h3 id="字符串变量类型"><a href="#字符串变量类型" class="headerlink" title="字符串变量类型"></a>字符串变量类型</h3><p>字符串也可作为单独的一种类型,只能赋值给本身。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> zero: <span class="string">"0"</span> = <span class="string">"0"</span>;</div><div class="line"><span class="keyword">let</span> one: <span class="string">"1"</span> = <span class="string">"1"</span>;</div><div class="line"><span class="keyword">let</span> two: <span class="string">"2"</span> = <span class="string">"10"</span><span class="comment">//Error：Type '"10"' is not assignable to type '"2"'.“10”类型不可以赋值给“2”类型</span></div></pre></td></tr></table></figure><p>因为字符串类型具有唯一性，可以当做对象的标识。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Circle = &#123;</div><div class="line">    kind: <span class="string">"Circle"</span>;</div><div class="line">    radius: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Square = &#123;</div><div class="line">    kind: <span class="string">"Square"</span>;</div><div class="line">    sideLength: <span class="built_in">number</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p>typescript 3.1新添加了一种类型 unknown,任何类型都是unknown的子类型，任何值都可以赋值给unknown的变量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> magic: unknown = <span class="literal">null</span>;</div><div class="line">magic = Symbol(<span class="string">"a"</span>);</div><div class="line">magic = <span class="literal">false</span>;</div><div class="line">magic = <span class="number">101</span>;</div><div class="line">magic = <span class="string">"3394"</span>;</div></pre></td></tr></table></figure><h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>never类型表示的是那些永不存在的值的类型。具体来说never类型是一个从来不会有返回值的函数或者一个总是会抛出错误的函数。never类型是所有类型的子类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 总是会抛出错误的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 从来不会有返回值的函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>never与void的差别：当一个函数没有返回值时，它返回了一个 void 类型，但是，当一个函数根本就没有返回值时（或者总是抛出错误），它返回了一个 never，void 指可以被赋值的类型（在 strictNullChecking 为 false 时），但是 never 不能赋值给其他任何类型，除了 never。</p></blockquote><p>所有的类型，unknown是类型系统的上界，never是类型系统的下界。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一章我们写了一个相加程序，可以完成数字和数字的相加，也可以完成字符串和字符串的相加，根据第一个参数，提示第二个参数的类型。如果把一个数字和字符串相加，编译器就会报错，是不是很智能呢？细心的会发现声明了一个类型：&lt;code&gt;type operator = string | number;&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;type是声明一个类型的关键字，不会新建一个类型，它创建了一个新名字来引用那个类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是我们完成类型检测的关键。下面我们来系统地学习typescript类型的奥秘，其中插入ES6语法的拓展。&lt;/p&gt;
&lt;h2 id=&quot;声明变量let、var、const&quot;&gt;&lt;a href=&quot;#声明变量let、var、const&quot; class=&quot;headerlink&quot; title=&quot;声明变量let、var、const&quot;&gt;&lt;/a&gt;声明变量let、var、const&lt;/h2&gt;&lt;h3 id=&quot;var导致的声明提升&quot;&gt;&lt;a href=&quot;#var导致的声明提升&quot; class=&quot;headerlink&quot; title=&quot;var导致的声明提升&quot;&gt;&lt;/a&gt;var导致的声明提升&lt;/h3&gt;&lt;p&gt;在ES6之前的变量声明,var的使用,看看下面的道理：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;span class=&quot;comment&quot;&gt;// undefined&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a);&lt;span class=&quot;comment&quot;&gt;// a = 1;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(b);&lt;span class=&quot;comment&quot;&gt;//Uncaught ReferenceError: b is not defined,引用错误b没有被声明&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;a和b打印出来的值不一样，为何？在javascript运行的过程中先会执行一遍预解析，使得变量a会被录入，但是没有执行赋值，故第一次打印a的值为undefined,赋值后打印a的值为1，变量b无声明，得到b is not defined。&lt;/p&gt;
&lt;h3 id=&quot;经典闭包问题的解决&quot;&gt;&lt;a href=&quot;#经典闭包问题的解决&quot; class=&quot;headerlink&quot; title=&quot;经典闭包问题的解决&quot;&gt;&lt;/a&gt;经典闭包问题的解决&lt;/h3&gt;&lt;p&gt;在JavaScript的面试中经常会碰到闭包问题，你能回答出下面的结果吗？&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;答案是5个5，思考一下。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="typescript" scheme="https://hqiwen.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>typescript介绍</title>
    <link href="https://hqiwen.github.io/2020/05/08/typescript%E4%BB%8B%E7%BB%8D/"/>
    <id>https://hqiwen.github.io/2020/05/08/typescript介绍/</id>
    <published>2020-05-08T05:40:34.000Z</published>
    <updated>2020-05-08T05:58:43.685Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript 简单来说是一门编程语言，与你熟知的 JavaScript、Java 和 C++ 之类的编程语言一样。既然有这么多的语言可供选择，为什么又要新创建一门语言？先看看官网对 TypeScript 的描述，TypeScript 是 JavaScript 类型的超集，它可以编译成纯JavaScript。那么为什么需要使用 TypeScript 而不是 JavaScript 呢？下面我将说服你为什么要使用 TypeScript。</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><h3 id="javaScript是一门好语言吗"><a href="#javaScript是一门好语言吗" class="headerlink" title="javaScript是一门好语言吗"></a>javaScript是一门好语言吗</h3><p>对于这个问题，不同的人有不同的想法。JavaScript 作为最多人使用的编程语言，也是在网页端取得绝对地位的语言，常常因为其动态类型、隐式转换而受到诟病。下面简要说明，一个完整的 JavaScript 包括三个不同的部分组成，核心（ESMAScript语言,简称ES），文档对象模型（DOM）和浏览器对象模型（BOM）,ESMAScript中有5种简单数据类型：undefined，null，boolean,number和string。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result1 = (<span class="string">"55"</span> == <span class="number">55</span>);  <span class="comment">//true,因为字符串“55”被转换数值55后相等</span></div><div class="line"><span class="keyword">var</span> result2 = (<span class="string">"55"</span> === <span class="number">55</span>);   <span class="comment">//false, 因为不同的类型不相等</span></div></pre></td></tr></table></figure><p>这看起来令人困惑，明明差不多的操作，得到的结果却截然相反，如果由于疏忽，少写了一个等号，会得到令人检测不到的 Bug。当然，你可能精通JavaScript，不会犯这种低级错误，但是如果和你合作的某个人，你能真正地保证他不会犯这种错误吗？</p><h3 id="CoffeeScript的出现"><a href="#CoffeeScript的出现" class="headerlink" title="CoffeeScript的出现"></a>CoffeeScript的出现</h3><p>为了减少犯这种错误的可能性，出现了CoffeeScript。CoffeeScript是一套javaScript的转译语言，于2009 年 12 月 24 日, 提交版本 0.0.1 ，创建者 Jeremy Ashkenas 戏称它是-JavaScript 的不那么铺张的小兄弟。因为 CoffeeScript 会将类似 Ruby 语法的代码编译成 JavaScript，而且大部分结构都相似，但不同的是 CoffeeScript 拥有更严格的语法。<br>在coffeeScript中，由于操作符<strong>==</strong>常常带来不准确的约束, 不容易达到效果, 而且跟其他语言当中意思不一致, CoffeeScript 会把 == 编译为 ===, 把 != 变异为 !==. 此外, is 编译为 ===, 而 isnt 编译为 !==，这样就避免了问题。<br>随着项目的日渐拓展，代码量越来越多，有了这样的代码：<br><a id="more"></a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Cat.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"can run"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fish</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Fish.prototype.swim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"can swim"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CatHome</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.home = [];</div><div class="line">&#125;</div><div class="line">CatHome.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">cat</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.home.push(cat);</div><div class="line">&#125;</div><div class="line">CatHome.prototype.count = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.home.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">cat</span>)</span>&#123;</div><div class="line">    cat.run();</div><div class="line">  &#125;)</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"there are "</span> + <span class="keyword">this</span>.home.length + <span class="string">" cats"</span>)</div><div class="line">&#125;</div><div class="line">---</div><div class="line"><span class="comment">//另外一处</span></div><div class="line"><span class="keyword">var</span> sam = <span class="keyword">new</span> Cat(<span class="string">"sam"</span>);</div><div class="line"><span class="keyword">var</span> lily = <span class="keyword">new</span> Fish(<span class="string">"lily"</span>);</div><div class="line"><span class="keyword">var</span> catHome = <span class="keyword">new</span> CatHome();</div><div class="line">catHome.add(sam);</div><div class="line">catHome.add(lily);  <span class="comment">//瞧，添加了一条鱼，却没有警告</span></div><div class="line">catHome.count();  <span class="comment">//error: cat.run is not a function，这个错误信息往往令人摸不着头脑</span></div></pre></td></tr></table></figure></p><p>之所以报错是因为 Fish 没有实现 run 方法，只有 swim 方法。当遇到这个问题的时候，开发者需要一步一步的检查代码，去找到每一个类的实现代码。</p><h3 id="TypeScript的曙光"><a href="#TypeScript的曙光" class="headerlink" title="TypeScript的曙光"></a>TypeScript的曙光</h3><p>2012年十月份，微软发布了首个公开版本的TypeScript，2013年6月19日，在经历了一个预览版之后微软正式发布了正式版TypeScript 0.9，向未来的TypeScript 1.0版迈进了很大一步。与JavaScript相比，TypeScript进步的地方包括：加入注释，让编译器理解所支持的对象和函数，编译器会移除注释，不会增加开销；增加一个完整的类结构，使之更像是传统的面型对象语言。<br>下面我们来品味一下，看看typescript是如何解决上面这个问题的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Cat&#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    run() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"can run"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> Fish&#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    swim() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"can swim"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">class</span> CatHome&#123;</div><div class="line">    home: Cat[];</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.home = [];</div><div class="line">    &#125;</div><div class="line">    add(cat:Cat) &#123;</div><div class="line">        <span class="keyword">this</span>.home.push(cat);</div><div class="line">    &#125;</div><div class="line">    count() &#123;</div><div class="line">        <span class="keyword">this</span>.home.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">cat</span>) </span>&#123;</div><div class="line">            cat.run();</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> sam = <span class="keyword">new</span> Cat(<span class="string">"sam"</span>);</div><div class="line"><span class="keyword">var</span> lily = <span class="keyword">new</span> Fish(<span class="string">"lily"</span>);</div><div class="line"><span class="keyword">var</span> catHome = <span class="keyword">new</span> CatHome();</div><div class="line">catHome.add(sam);</div><div class="line">catHome.add(lily);</div><div class="line"><span class="comment">//Argument of type 'Fish' is not assignable to parameter of type 'Cat'.函数参数是Cat类型，传入的Fish类型不可以赋值给Cat类型</span></div><div class="line"><span class="comment">//Property 'run' is missing in type 'Fish' but required in type 'Cat'.Cat类型必要要有run方法，而Fish里面没有run方法</span></div><div class="line">catHome.count();</div></pre></td></tr></table></figure><p>可以看到编译器对catHome的内部数组进行了检测，当我们调用add方法时，会检测添加实例是不是一个Cat类。从错误信息中还能得到Cat类必须要有run方法，但是Fish类没有。</p><h2 id="自定义的一个类型系统"><a href="#自定义的一个类型系统" class="headerlink" title="自定义的一个类型系统"></a>自定义的一个类型系统</h2><h3 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h3><p>程序所表达的含义简称语义。语义是程序执行时所表达出来的思想，原程序通过解释器或编译器的执行，让静止不动的代码得到了含义，可以被另一种语言去执行和翻译，最终翻译成计算机可执行的指令。</p><p>程序有动态语义和静态语义之分。静态语义是指在编译阶段能够检查的语义，比如标识符未定义，类型不匹配等。动态语义是指在目标程序运行阶段能够检查的语义，比如除数为0，无效指针，数组下标越界等。</p><p>动态语义需要程序运行才能分析，但有时运行原程序不可逆或消耗时间太长，但是发现不实际执行的程序的问题很重要。分析程序的静态语义，可以让不实际程序执行计算而能发现它的近似信息。类型系统是静态分析的经典例子。</p><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>下面添加三种类型，分别是正、负和零。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Sign&#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Sign.POSITIVE = <span class="keyword">new</span> Sign(<span class="string">"positive"</span>)</div><div class="line">Sign.NEGATIVE = <span class="keyword">new</span> Sign(<span class="string">"negative"</span>)</div><div class="line">Sign.ZERO = <span class="keyword">new</span> Sign(<span class="string">"zero"</span>)</div></pre></td></tr></table></figure><h3 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h3><p>添加类型的规则和操作</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Sign&#123;</div><div class="line">    <span class="comment">//...接上文的代码</span></div><div class="line">    <span class="comment">//为类型添加规则</span></div><div class="line">    multiply(other_sign) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> === Sign.ZERO || other_sign === Sign.ZERO) &#123;</div><div class="line">            <span class="comment">//任何一个数乘以0等于0</span></div><div class="line">            <span class="keyword">return</span> Sign.ZERO</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span> === other_sign) &#123;</div><div class="line">            <span class="comment">// 符号相同得正</span></div><div class="line">            <span class="keyword">return</span> Sign.POSITIVE;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// 符号相反得负</span></div><div class="line">            <span class="keyword">return</span> Sign.NEGATIVE;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="将程序与类型相连"><a href="#将程序与类型相连" class="headerlink" title="将程序与类型相连"></a>将程序与类型相连</h3><p>把源程序中的值与类型系统中的值相关联。小于0返回一个负类型，等于0返回一个0类型，大于0返回一个正类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Numeric&#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">value</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 为值添加类型</span></div><div class="line">    sign() &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.value &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Sign.NEGATIVE;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.value = <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> Sign.ZERO</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> Sign.POSITIVE;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//为了使用方便，封装一个函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createNumeric</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Numeric(value).sign();</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="解释源程序"><a href="#解释源程序" class="headerlink" title="解释源程序"></a>解释源程序</h3><p>下面调用函数解释源程序的含义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 不用运算结果，我们便可以知道结果是一个负值</span></div><div class="line"><span class="comment"> */</span></div><div class="line">createNumeric(<span class="number">6</span>).multiply(createNumeric(<span class="number">-9</span>)).toString();<span class="comment">//"negative"</span></div></pre></td></tr></table></figure><p>这里我们得到了计算的结果的一点近似信息，通过类型系统的解释，结果是一个负数，显然程序结果是正还是负没有太大的意义，但是这是一个很好的起点，可以预见更加强壮的类型系统会为我们带来更多的信息，现代编译系统在构建语法树后会对程序进行语义分析，其中静态分析是很重要的一环。</p><p>编辑器插件对程序进行分析，在内部进行编译执行，让我们在程序编写时就能获得很多提示，提高开发效率和减少犯错误的几率。</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>为什么要选择typescript？</p><h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p>在Typescript里面是运行为变量指定类型的，比如当你为这个变量指定数字类型的值的时候，IDE会做出类型检查，然后告诉你这里可能会有错误，这个特性会减少你在开发阶段犯错误的几率。</p><h3 id="语法提示"><a href="#语法提示" class="headerlink" title="语法提示"></a>语法提示</h3><p>在IDE里面去编写TypeScript的代码时，IDE会根据你当前的上下文，把你能用的类、变量、方法和关键字都给你提示出来，你只要直接去选就可以了，这个特性会大大提升你的开发效率</p><h3 id="项目重构"><a href="#项目重构" class="headerlink" title="项目重构"></a>项目重构</h3><p>重构使你可以很方便的去修改你的变量或者方法的名字或者是文件的名字，当你做出这些修改的时候，IDE会帮你自动引用这个变量或者调用这个方法地方的代码自动帮你修改掉，这个特性一个是会提高你的开发效率，另一个是可以很容易的提升你的代码质量</p><p>Typescript的好处很明显，在编译时就能检查出很多语法问题而不是在运行时。不过由于是面向对象思路，如果是纯前端的人员（没有后端语言基础），那用起来应该是比较吃力的。好的框架和语言能间接帮助开发者写出规范的代码，Typescript能使团队易于协同开发，提高效率，这是typescript生态取代JavaScript生态的原因。</p><h2 id="谁在使用它们"><a href="#谁在使用它们" class="headerlink" title="谁在使用它们"></a>谁在使用它们</h2><p>既然typeScript有那么好，这样的语言有实践先例吗？</p><h3 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h3><p>著名游戏引擎白鹭，遵循HTML5标准的2D、3D引擎，解决了HTML5性能问题及碎片化问题，灵活地满足开发者开发2D或3D游戏的需求，并有着较强的跨平台运行能力。在 Egret 中，需使用 TypeScript 编写程序，最终编译成浏览器可读的 JavaScript。</p><h3 id="Heroku"><a href="#Heroku" class="headerlink" title="Heroku"></a>Heroku</h3><p>Heroku是一个支持多种编程语言的云平台即服务。在2010年被Salesforce.com收购。Heroku作为最开始的云平台之一，从2007年6月起开发，当时它仅支持Ruby，但后来增加了对Java、Node.js、Scala、Clojure、Python 以及（未记录在正式文件上）PHP和Perl的支持。基础操作系统是Debian，在最新的堆栈则是基于 Debian 的 Ubuntu。</p><h3 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h3><p>由于目前腾讯没有小程序的TypeScript版本的API，所以 OneCode team 针对目前腾讯放出的所有的小程序 JavaScript API 开发了一个 TypeScript 版本的API类型定义文件 wxAPI.d.ts，只需要在您的程序中引用该文件，如果是使用 Visual Studio 来开发的话，就能有代码提示了。</p><h3 id="Vue-3-0"><a href="#Vue-3-0" class="headerlink" title="Vue 3.0"></a>Vue 3.0</h3><p>Vue 3.0 会改进对 TypeScript 的支持，允许在编辑器中进行高级的类型检查和有用的错误和警告。</p><h2 id="Typescript-组成"><a href="#Typescript-组成" class="headerlink" title="Typescript 组成"></a>Typescript 组成</h2><p>TypeScript 为 JavaScript 添加了类型注释，通过添加 d.ts 文件，让 TypeScript 衔接 JavaScript 生态，所有版本的JavaScript将会得到 TypeScript良好的支持。在 ESMAScript 版本中，ESMAScript2015 又称 ES6 是一个比较重要的版本，TypeScript 包括了ES6的语法，从某种程度上来说，ts = js + d.ts。</p><h2 id="如何初始化一个-TypeScript-项目"><a href="#如何初始化一个-TypeScript-项目" class="headerlink" title="如何初始化一个 TypeScript 项目"></a>如何初始化一个 TypeScript 项目</h2><h3 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h3><p>有两种主要的方式来获取 TypeScript 工具：</p><ul><li>通过npm（Node.js包管理器）</li><li>安装Visual Studio的TypeScript插件<br>Visual Studio 2017和Visual Studio 2015 Update 3默认包含了TypeScript。 如果你的Visual Studio还没有安装TypeScript，你可以下载它。</li></ul><p>针对使用npm的用户：</p><blockquote><p>npm install -g typescript</p></blockquote><h3 id="编写我们的第一个-ts-文件"><a href="#编写我们的第一个-ts-文件" class="headerlink" title="编写我们的第一个 ts 文件"></a>编写我们的第一个 ts 文件</h3><p>新建 add.ts 文件，内容如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//声明一个类型</span></div><div class="line"><span class="keyword">type</span> operator = <span class="built_in">string</span> | <span class="built_in">number</span>;</div><div class="line"></div><div class="line"><span class="comment">//对operator类型进行操作</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>&lt;<span class="title">operator</span>&gt;(<span class="params">operator1: operator, operator2: operator</span>) </span>&#123;</div><div class="line">  <span class="comment">//判断类型为string并相加</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> operator1 === <span class="string">"string"</span> &amp;&amp; <span class="keyword">typeof</span> operator2 === <span class="string">"string"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> operator1 + operator2;</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//判断类型为number并相加</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> operator1 === <span class="string">"number"</span> &amp;&amp; <span class="keyword">typeof</span> operator2 === <span class="string">"number"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> operator1 + operator2;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//2</span></div><div class="line"></div><div class="line">add(<span class="string">"hello"</span>, <span class="string">" world"</span>);<span class="comment">//hello world</span></div></pre></td></tr></table></figure><h3 id="编译和执行我们的-TypeScript-文件"><a href="#编译和执行我们的-TypeScript-文件" class="headerlink" title="编译和执行我们的 TypeScript 文件"></a>编译和执行我们的 TypeScript 文件</h3><p>在命令行上，运行 TypeScript 编译器编译文件：</p><blockquote><p>tsc add.ts</p></blockquote><p>输出结果为一个add.js文件，它包含了和输入文件中相同的JavaScript代码。 一切准备就绪，我们可以运行这个使用TypeScript写的JavaScript应用了！</p><blockquote><p>node add.js</p></blockquote><p>由于我们什么都没有输出，也没有阻塞进程，程序执行完就会被退出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript 简单来说是一门编程语言，与你熟知的 JavaScript、Java 和 C++ 之类的编程语言一样。既然有这么多的语言可供选择，为什么又要新创建一门语言？先看看官网对 TypeScript 的描述，TypeScript 是 JavaScript 类型的超集，它可以编译成纯JavaScript。那么为什么需要使用 TypeScript 而不是 JavaScript 呢？下面我将说服你为什么要使用 TypeScript。&lt;/p&gt;
&lt;h2 id=&quot;历史&quot;&gt;&lt;a href=&quot;#历史&quot; class=&quot;headerlink&quot; title=&quot;历史&quot;&gt;&lt;/a&gt;历史&lt;/h2&gt;&lt;h3 id=&quot;javaScript是一门好语言吗&quot;&gt;&lt;a href=&quot;#javaScript是一门好语言吗&quot; class=&quot;headerlink&quot; title=&quot;javaScript是一门好语言吗&quot;&gt;&lt;/a&gt;javaScript是一门好语言吗&lt;/h3&gt;&lt;p&gt;对于这个问题，不同的人有不同的想法。JavaScript 作为最多人使用的编程语言，也是在网页端取得绝对地位的语言，常常因为其动态类型、隐式转换而受到诟病。下面简要说明，一个完整的 JavaScript 包括三个不同的部分组成，核心（ESMAScript语言,简称ES），文档对象模型（DOM）和浏览器对象模型（BOM）,ESMAScript中有5种简单数据类型：undefined，null，boolean,number和string。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result1 = (&lt;span class=&quot;string&quot;&gt;&quot;55&quot;&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;55&lt;/span&gt;);  &lt;span class=&quot;comment&quot;&gt;//true,因为字符串“55”被转换数值55后相等&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; result2 = (&lt;span class=&quot;string&quot;&gt;&quot;55&quot;&lt;/span&gt; === &lt;span class=&quot;number&quot;&gt;55&lt;/span&gt;);   &lt;span class=&quot;comment&quot;&gt;//false, 因为不同的类型不相等&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这看起来令人困惑，明明差不多的操作，得到的结果却截然相反，如果由于疏忽，少写了一个等号，会得到令人检测不到的 Bug。当然，你可能精通JavaScript，不会犯这种低级错误，但是如果和你合作的某个人，你能真正地保证他不会犯这种错误吗？&lt;/p&gt;
&lt;h3 id=&quot;CoffeeScript的出现&quot;&gt;&lt;a href=&quot;#CoffeeScript的出现&quot; class=&quot;headerlink&quot; title=&quot;CoffeeScript的出现&quot;&gt;&lt;/a&gt;CoffeeScript的出现&lt;/h3&gt;&lt;p&gt;为了减少犯这种错误的可能性，出现了CoffeeScript。CoffeeScript是一套javaScript的转译语言，于2009 年 12 月 24 日, 提交版本 0.0.1 ，创建者 Jeremy Ashkenas 戏称它是-JavaScript 的不那么铺张的小兄弟。因为 CoffeeScript 会将类似 Ruby 语法的代码编译成 JavaScript，而且大部分结构都相似，但不同的是 CoffeeScript 拥有更严格的语法。&lt;br&gt;在coffeeScript中，由于操作符&lt;strong&gt;==&lt;/strong&gt;常常带来不准确的约束, 不容易达到效果, 而且跟其他语言当中意思不一致, CoffeeScript 会把 == 编译为 ===, 把 != 变异为 !==. 此外, is 编译为 ===, 而 isnt 编译为 !==，这样就避免了问题。&lt;br&gt;随着项目的日渐拓展，代码量越来越多，有了这样的代码：&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="typescript" scheme="https://hqiwen.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>koa装饰器</title>
    <link href="https://hqiwen.github.io/2019/09/07/koa%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>https://hqiwen.github.io/2019/09/07/koa装饰器/</id>
    <published>2019-09-07T03:25:56.000Z</published>
    <updated>2019-09-07T03:42:03.553Z</updated>
    
    <content type="html"><![CDATA[<p>装饰器是一种特殊类型的声明，可以用来“装饰”三种类型的对象：类的属性/方法、访问器、类本身。装饰器使用<code>@expression</code>这种形式，expression求值后必须为一个函数，称为装饰器工厂函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p><p>注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数<br>注意装饰器的调用顺序：</p><ol><li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。</li><li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。</li><li>参数装饰器应用到构造函数。</li><li>类装饰器应用到类。</li></ol><p>参数装饰器会在方法装饰器之前调用，对参数进行注解，外部装饰器可以拿到注解。</p><h2 id="解析现代koa装饰器"><a href="#解析现代koa装饰器" class="headerlink" title="解析现代koa装饰器"></a>解析现代koa装饰器</h2><p>下面来一段装饰器写法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// CatController.ts</span></div><div class="line"><span class="keyword">import</span> &#123; Path, Get, Post, Param, Query, Body &#125; <span class="keyword">from</span> <span class="string">'koa-decorate'</span>;</div><div class="line"></div><div class="line"><span class="meta">@Path</span>(<span class="string">'/api/cat'</span>)</div><div class="line"><span class="keyword">class</span> CatController &#123;</div><div class="line"></div><div class="line">  <span class="meta">@Get</span></div><div class="line">  <span class="meta">@Path</span>(<span class="string">'/info/:type'</span>)</div><div class="line">  getCatInfo (</div><div class="line">      <span class="meta">@Param</span>(<span class="string">'type'</span>) <span class="keyword">type</span>: <span class="built_in">string</span>,</div><div class="line">      <span class="meta">@Query</span>(<span class="string">'info'</span>) info: <span class="built_in">string</span>) &#123;</div><div class="line">    <span class="keyword">return</span> &#123; <span class="keyword">type</span>, info &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Post</span></div><div class="line">  <span class="meta">@Path</span>(<span class="string">'/info/:type'</span>)</div><div class="line">  CreateCat (</div><div class="line">      <span class="meta">@Param</span>(<span class="string">'type'</span>) <span class="keyword">type</span>: <span class="built_in">string</span>,</div><div class="line">      <span class="meta">@Body</span>(<span class="string">'requestBody'</span>) requestBody: <span class="built_in">any</span>) &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      status: <span class="number">200</span>,</div><div class="line">      data: <span class="built_in">Object</span>.assign(requestBody, &#123; <span class="keyword">type</span> &#125;),</div><div class="line">      message: <span class="string">'Created successfully...'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123; CatController &#125;;</div></pre></td></tr></table></figure><p>这是一段TypeScript上 koa 路由类的写法，注意到在其中，使用了@Paht @Get的写法, 并且在入参中也有<code>@PathParam(&#39;id&#39;) id: number</code>这样的写法。这就是装饰器。其中 @Path(‘/api’)中的API是这个装饰器的入参，在这里是注解，因为这个框架通过Reflect.defineMetadata将这个入参写入到了该方法中。</p><blockquote><p>Reflect.defineMetadata是一种反射的写法，保存一个对象到缓存中，通过Reflect.getMetadata来访问缓存，无需做过多操作</p></blockquote><p>思考一下该如何实现。</p><p>上面我们一共引入了六个装饰器<code>Path, Get, Post, Param, Query, Body</code>, 其中path既是类装饰器又是方法装饰器，get和post是方法装饰器，且装饰在path方法装饰器之上，Param, Query, Body 是属性装饰器。考虑到装饰器的执行顺序，先是属性装饰器，再是方法装饰器，然后是类装饰器。</p><h3 id="koa-decorate-参数装饰器"><a href="#koa-decorate-参数装饰器" class="headerlink" title="koa-decorate 参数装饰器"></a>koa-decorate 参数装饰器</h3><p>三个参数装饰器 Param, Query, Body 很简单，定义一个独一无二的<code>Symbol</code>类型的键,保存被修饰的参数的值和索引。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> paramSymbolKey = Symbol.for(<span class="string">"param"</span>);</div><div class="line"><span class="keyword">const</span> querySymbolKey = Symbol.for(<span class="string">"query"</span>);</div><div class="line"><span class="keyword">const</span> bodySymbolKey = Symbol.for(<span class="string">"body"</span>);</div><div class="line"><span class="comment">// 参数装饰器，定义一个target.propertyKey[Param]对象，并设置对象的argName = argIndex</span></div><div class="line"><span class="keyword">const</span> Param = <span class="function"><span class="params">argName</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            target: <span class="built_in">Object</span>,</div><div class="line">            propertyKey: <span class="built_in">string</span> | symbol,</div><div class="line">            argIndex: <span class="built_in">number</span></div><div class="line">        ) =&gt; &#123;</div><div class="line">            <span class="comment">// 获取保存在target.propertyKey[param]的值，如果不存在，就设置一个空对象</span></div><div class="line">            <span class="keyword">const</span> args =</div><div class="line">                Reflect.getMetadata(paramSymbolKey, target, propertyKey) || &#123;&#125;;</div><div class="line">            <span class="comment">// 设置对象的argName = argIndex，键为被修饰的值，值为参数的索引</span></div><div class="line">            args[argName] = argIndex;</div><div class="line">            <span class="comment">// 设置新的target.propertyKey[param]的值</span></div><div class="line">            Reflect.defineMetadata(paramSymbolKey, args, target, propertyKey);</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure><p>query 和 body 参数装饰器与 param 装饰器的内容大同小异，只不过是保存的不同的键的对象。<br><a id="more"></a></p><h3 id="koa-decorate-方法装饰器"><a href="#koa-decorate-方法装饰器" class="headerlink" title="koa-decorate 方法装饰器"></a>koa-decorate 方法装饰器</h3><p>在参数装饰器保存了被修饰的参数的值和索引之后，方法装饰器就可以拿到相应的值，并处理一定的逻辑。path装饰器比较重要，这里详细说明。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> routeSymbolKey = Symbol.for(<span class="string">"route"</span>);</div><div class="line"><span class="keyword">const</span> pathSymbolKey = Symbol.for(<span class="string">"path"</span>);</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* 方法装饰器，传入一个字符串</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Path = (path: <span class="built_in">string</span>): <span class="function"><span class="params">Function</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        target: <span class="built_in">Function</span>,</div><div class="line">        propertyKey: <span class="built_in">string</span> | symbol,</div><div class="line">        decorator: PropertyDescriptor</div><div class="line">    ) =&gt; &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 把原方法设置成一个函数，传递一个控制器，返回一个中间件设置ctx.param与ctx.body</span></div><div class="line"><span class="comment">        */</span></div><div class="line">         <span class="comment">// 定义routes,值为@path修饰的方法组成的数组</span></div><div class="line">         <span class="keyword">const</span> routeMethods =</div><div class="line">             Reflect.getMetadata(routeSymbolKey, target) || [];</div><div class="line">         routeMethods.push(propertyKey);</div><div class="line">         Reflect.defineMetadata(routeSymbolKey, routeMethods, target);</div><div class="line">         <span class="comment">// 定义Path，值为@path的参数</span></div><div class="line">         Reflect.defineMetadata(pathSymbolKey, path, target, propertyKey);</div><div class="line">         <span class="comment">// 保存原函数</span></div><div class="line">         <span class="keyword">const</span> oldMethodValue = decorator.value;</div><div class="line">         <span class="comment">// 这里instance是一个控制器对象，用来调用控制器中被方法修饰器中的函数</span></div><div class="line">         decorator.value = <span class="function">(<span class="params">instance: <span class="built_in">Object</span></span>) =&gt;</span> <span class="keyword">async</span> (ctx, next) =&gt; </div><div class="line">             <span class="keyword">const</span> args = [];</div><div class="line">             <span class="comment">// 获取参数装饰器的保存的对象，为值和索引的键值对</span></div><div class="line">             <span class="keyword">const</span> param = Reflect.getMetadata(</div><div class="line">                 paramSymbolKey,</div><div class="line">                 target,</div><div class="line">                 propertyKey</div><div class="line">             );</div><div class="line">             <span class="comment">// 如果param存在，把ctx.params对象上的值代理到args.param对象</span></div><div class="line">             param &amp;&amp;</div><div class="line">                 <span class="built_in">Object</span>.keys(param).map(</div><div class="line">                     key =&gt; (args[param[key]] = ctx.params[key])</div><div class="line">                 );</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 把 ctx.query 对象上的值代理到 args.query 对象</span></div><div class="line"><span class="comment">             */</span></div><div class="line">             <span class="keyword">const</span> query = Reflect.getMetadata(</div><div class="line">                 querySymbolKey,</div><div class="line">                 target,</div><div class="line">                 propertyKey</div><div class="line">             );</div><div class="line">             query &amp;&amp;</div><div class="line">                 <span class="built_in">Object</span>.keys(query).map(</div><div class="line">                     key =&gt; (args[query[key]] = ctx.query)</div><div class="line">                 );</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             * 把 ctx.body 对象上的值代理到 args.body 对象</span></div><div class="line"><span class="comment">             */</span></div><div class="line">             <span class="keyword">const</span> body = Reflect.getMetadata(</div><div class="line">                 bodySymbolKey,</div><div class="line">                 target,</div><div class="line">                 propertyKey</div><div class="line">             );</div><div class="line">             body &amp;&amp;</div><div class="line">                 <span class="built_in">Object</span>.keys(body).map(</div><div class="line">                     key =&gt; (args[body[key]] = ctx.request.body)</div><div class="line">                 );</div><div class="line">            <span class="comment">// 调用闭包中的原函数</span></div><div class="line">             <span class="keyword">const</span> result = <span class="keyword">await</span> oldMethodValue.apply(instance, args);</div><div class="line">             ctx.body = result;</div><div class="line">        &#125;;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>get 和 post 方法装饰器</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> httpMethodSymbolKey = Symbol.for(<span class="string">"httpMethod"</span>);</div><div class="line"><span class="keyword">const</span> [Get, Post, Put, Delete, All] = [</div><div class="line">    <span class="string">"get"</span>,</div><div class="line">    <span class="string">"post"</span>,</div><div class="line">    <span class="string">"put"</span>,</div><div class="line">    <span class="string">"delete"</span>,</div><div class="line">    <span class="string">"all"</span></div><div class="line">].map(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">target, propertyKey</span>) =&gt;</span> &#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         * 保存被修饰函数的httpMethodSymbolKey为method(get/post)</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        Reflect.defineMetadata(</div><div class="line">            httpMethodSymbolKey,</div><div class="line">            method,</div><div class="line">            target,</div><div class="line">            propertyKey</div><div class="line">        );</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="koa-decorate-类装饰器"><a href="#koa-decorate-类装饰器" class="headerlink" title="koa-decorate 类装饰器"></a>koa-decorate 类装饰器</h3><p>path类装饰器和方法装饰器共用一个函数，这里用来定义根路径。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> rootPathSymbolKey = Symbol.for(<span class="string">"rootPath"</span>);</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> Path = (path: <span class="built_in">string</span>): <span class="function"><span class="params">Function</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        target: <span class="built_in">Function</span>,</div><div class="line">        propertyKey: <span class="built_in">string</span> | symbol,</div><div class="line">        decorator: PropertyDescriptor</div><div class="line">    ) =&gt; &#123;</div><div class="line">        <span class="comment">// 类修饰器</span></div><div class="line">        <span class="keyword">if</span> (propertyKey === <span class="literal">undefined</span> &amp;&amp; decorator === <span class="literal">undefined</span>) &#123;</div><div class="line">            <span class="comment">// 保存被修饰类的rootPathSymbolKey的值为path</span></div><div class="line">            Reflect.defineMetadata(rootPathSymbolKey, path, target.prototype);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//方法装饰器</span></div><div class="line">        &#125;</div></pre></td></tr></table></figure><p>经过一系列装饰器的处理，我们只是保存了很多值，但是并没有使用，下面的将把这些值挂载在koa-router的Router对象上，用来实现相应的路由。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Decorator &#123;</div><div class="line">  <span class="keyword">private</span> router: Router;<span class="comment">// 路由</span></div><div class="line">  <span class="keyword">private</span> controller: <span class="built_in">Object</span>; <span class="comment">// 控制器</span></div><div class="line"></div><div class="line">  <span class="keyword">constructor</span> (<span class="params">options</span>) &#123;</div><div class="line">    <span class="keyword">const</span> &#123;router, controllers&#125; = options;</div><div class="line">    <span class="keyword">if</span> (!controllers) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'There is no configuration properties "controllers"'</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.router      = router || <span class="keyword">new</span> Router();</div><div class="line">    <span class="keyword">this</span>.controllers = controllers;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> addRoutes (Controller) &#123;</div><div class="line">    <span class="comment">// 控制器</span></div><div class="line">    <span class="keyword">const</span> instance     = <span class="keyword">new</span> Controller();</div><div class="line">    <span class="comment">// 拿到rootPath</span></div><div class="line">    <span class="keyword">const</span> rootPath     = Reflect.getMetadata(rootPathSymbolKey, Controller.prototype);</div><div class="line">    <span class="comment">// 拿到routes,值为控制器内被@path修饰的方法所组成的数组</span></div><div class="line">    <span class="keyword">const</span> routes       = Reflect.getMetadata(routeSymbolKey, Controller.prototype);</div><div class="line"></div><div class="line">    routes.map(<span class="function">(<span class="params">routeName: <span class="built_in">string</span></span>) =&gt;</span> &#123;</div><div class="line">    <span class="comment">// method为控制器内被@path修饰的方法</span></div><div class="line">      <span class="keyword">const</span> method     = instance[routeName];</div><div class="line">      <span class="comment">// 拿到http方法，有@get、@post等定义，与@Param相差不多，故省略</span></div><div class="line">      <span class="keyword">const</span> httpMethod = Reflect.getMetadata(httpMethodSymbolKey, Controller.prototype, routeName);</div><div class="line">       <span class="comment">// 拿到控制器内被@path的参数</span></div><div class="line">      <span class="keyword">const</span> path       = Reflect.getMetadata(pathSymbolKey, Controller.prototype, routeName);</div><div class="line">      <span class="comment">// method(instance) 返回中间件</span></div><div class="line">      <span class="keyword">this</span>.router[httpMethod](<span class="string">`<span class="subst">$&#123;rootPath&#125;</span><span class="subst">$&#123;path&#125;</span>`</span>, method(instance));</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">new</span> Decorator(<span class="keyword">new</span> Router(), CatController);</div></pre></td></tr></table></figure><p>装饰器通过参数注解以<code>Reflect.defineMetadata</code>在缓存中形成一种配置，通过<code>Reflect.getMetadata</code>拿到配置，实现相应的功能。</p><p>参考文献: <a href="https://github.com/6peiweb/koa-decorate" target="_blank" rel="external">koa-decorate</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装饰器是一种特殊类型的声明，可以用来“装饰”三种类型的对象：类的属性/方法、访问器、类本身。装饰器使用&lt;code&gt;@expression&lt;/code&gt;这种形式，expression求值后必须为一个函数，称为装饰器工厂函数，它会在运行时被调用，被装饰的声明信息做为参数传入。&lt;/p&gt;
&lt;p&gt;注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数&lt;br&gt;注意装饰器的调用顺序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。&lt;/li&gt;
&lt;li&gt;参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。&lt;/li&gt;
&lt;li&gt;参数装饰器应用到构造函数。&lt;/li&gt;
&lt;li&gt;类装饰器应用到类。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参数装饰器会在方法装饰器之前调用，对参数进行注解，外部装饰器可以拿到注解。&lt;/p&gt;
&lt;h2 id=&quot;解析现代koa装饰器&quot;&gt;&lt;a href=&quot;#解析现代koa装饰器&quot; class=&quot;headerlink&quot; title=&quot;解析现代koa装饰器&quot;&gt;&lt;/a&gt;解析现代koa装饰器&lt;/h2&gt;&lt;p&gt;下面来一段装饰器写法：&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// CatController.ts&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; Path, Get, Post, Param, Query, Body &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;koa-decorate&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Path&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;/api/cat&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; CatController &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Get&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Path&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;/info/:type&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  getCatInfo (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Param&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;type&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Query&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;info&#39;&lt;/span&gt;) info: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt;, info &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Post&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Path&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;/info/:type&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  CreateCat (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Param&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;type&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;meta&quot;&gt;@Body&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;requestBody&#39;&lt;/span&gt;) requestBody: &lt;span class=&quot;built_in&quot;&gt;any&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      status: &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      data: &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.assign(requestBody, &amp;#123; &lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; &amp;#125;),&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      message: &lt;span class=&quot;string&quot;&gt;&#39;Created successfully...&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &amp;#123; CatController &amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是一段TypeScript上 koa 路由类的写法，注意到在其中，使用了@Paht @Get的写法, 并且在入参中也有&lt;code&gt;@PathParam(&amp;#39;id&amp;#39;) id: number&lt;/code&gt;这样的写法。这就是装饰器。其中 @Path(‘/api’)中的API是这个装饰器的入参，在这里是注解，因为这个框架通过Reflect.defineMetadata将这个入参写入到了该方法中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reflect.defineMetadata是一种反射的写法，保存一个对象到缓存中，通过Reflect.getMetadata来访问缓存，无需做过多操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思考一下该如何实现。&lt;/p&gt;
&lt;p&gt;上面我们一共引入了六个装饰器&lt;code&gt;Path, Get, Post, Param, Query, Body&lt;/code&gt;, 其中path既是类装饰器又是方法装饰器，get和post是方法装饰器，且装饰在path方法装饰器之上，Param, Query, Body 是属性装饰器。考虑到装饰器的执行顺序，先是属性装饰器，再是方法装饰器，然后是类装饰器。&lt;/p&gt;
&lt;h3 id=&quot;koa-decorate-参数装饰器&quot;&gt;&lt;a href=&quot;#koa-decorate-参数装饰器&quot; class=&quot;headerlink&quot; title=&quot;koa-decorate 参数装饰器&quot;&gt;&lt;/a&gt;koa-decorate 参数装饰器&lt;/h3&gt;&lt;p&gt;三个参数装饰器 Param, Query, Body 很简单，定义一个独一无二的&lt;code&gt;Symbol&lt;/code&gt;类型的键,保存被修饰的参数的值和索引。&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; paramSymbolKey = Symbol.for(&lt;span class=&quot;string&quot;&gt;&quot;param&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; querySymbolKey = Symbol.for(&lt;span class=&quot;string&quot;&gt;&quot;query&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; bodySymbolKey = Symbol.for(&lt;span class=&quot;string&quot;&gt;&quot;body&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 参数装饰器，定义一个target.propertyKey[Param]对象，并设置对象的argName = argIndex&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; Param = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;argName&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            target: &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            propertyKey: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; | symbol,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            argIndex: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 获取保存在target.propertyKey[param]的值，如果不存在，就设置一个空对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; args =&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Reflect.getMetadata(paramSymbolKey, target, propertyKey) || &amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 设置对象的argName = argIndex，键为被修饰的值，值为参数的索引&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            args[argName] = argIndex;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 设置新的target.propertyKey[param]的值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            Reflect.defineMetadata(paramSymbolKey, args, target, propertyKey);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;query 和 body 参数装饰器与 param 装饰器的内容大同小异，只不过是保存的不同的键的对象。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="typescript" scheme="https://hqiwen.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>typescript接口</title>
    <link href="https://hqiwen.github.io/2019/09/06/typescript%E6%8E%A5%E5%8F%A3/"/>
    <id>https://hqiwen.github.io/2019/09/06/typescript接口/</id>
    <published>2019-09-06T08:24:03.000Z</published>
    <updated>2019-09-07T02:52:26.373Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机中，接口是计算机系统中两个独立的部件进行信息交换的共享边界。这种交换可以发生在计算机软、硬件，外部设备或进行操作的人之间，也可以是它们的结合。<br>Typescript通过类型检查的方式减少了程序犯错误的机率，但是不能约束代码的产出方式，模块暴露出的API变更之后会产生一系列的麻烦。在TypeScript里，接口的作用就是规范代码，为需要约束的类型命名和为你的代码或第三方代码定义产出方式。因为typescript认为约束条件一样时是属于同一类，所以它有时被称做“鸭式辨型法”或“结构性子类型化”。</p><h2 id="具名接口"><a href="#具名接口" class="headerlink" title="具名接口"></a>具名接口</h2><p>通过<code>interface</code>关键词为<strong>约束条件</strong>添加名字，主要为对象和函数添加约束，利用typescript中提到的类型：</p><ol><li>string</li><li>number</li><li>boolean</li><li>symbol</li><li>array</li><li>function</li><li>object</li><li>null</li><li>undefined</li><li>any</li><li>void</li><li>tuple</li><li>unknown</li><li>never</li><li>字面量类型</li></ol><h3 id="对象的接口"><a href="#对象的接口" class="headerlink" title="对象的接口"></a>对象的接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> User&#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    id: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Car&#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    id: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> user: User = &#123;</div><div class="line">    name: <span class="string">"lily"</span>,</div><div class="line">    id: <span class="number">3</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> car: Car = &#123;</div><div class="line">    name: <span class="string">"tick"</span>,</div><div class="line">    id: <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserName</span>(<span class="params">user: User</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> user.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">getUserName(car);</div></pre></td></tr></table></figure><p>函数getUserName限制传入参数为User类，可是我们传入了一个Car类，并且没有报错，这是为什么呢？User类的约束条件为<code>function test(obj) { return obj === {} &amp;&amp; obj.name !== undefined &amp;&amp; obj.id !== undefined;}</code>,同时Car类的约束条件也是一样的，所以函数可以传入Car类，所以typescript有时被称做“鸭式辨型法”或“结构性子类型化”。</p><h3 id="函数的接口"><a href="#函数的接口" class="headerlink" title="函数的接口"></a>函数的接口</h3><p>为函数添加约束条件，约束函数的传入参数和返回值，与第四章添加函数的类型检查时一样。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> isArray&#123;</div><div class="line">    (array: []): <span class="built_in">boolean</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> isArray : isArray = <span class="function"><span class="keyword">function</span>(<span class="params">array: []</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(array) === <span class="string">'[object Array]'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="属性的约束"><a href="#属性的约束" class="headerlink" title="属性的约束"></a>属性的约束</h2><p>检查对象的属性分为必须、可选、只读，函数的参数有必须、可选之分</p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>有时候不确定某个属性是否存在时，在声明的属性后面加入一个<code>?</code>，就可以使属性变得可选。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> User&#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    id?: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> user: User = &#123;</div><div class="line">    name: <span class="string">"boy"</span>,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> user1:User = &#123;</div><div class="line">    name: <span class="string">"jack"</span>,</div><div class="line">    id: <span class="number">4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createUser</span>(<span class="params">name: <span class="built_in">string</span>, id?: <span class="built_in">number</span></span>): <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        name: name,</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>检查条件为<code>function test(obj) { return (obj === {} &amp;&amp; obj.name !== undefined &amp;&amp; obj.id !== undefined;) || obj === {} &amp;&amp; obj.id !== undefined;}</code><br><a id="more"></a><br><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> User&#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    id?: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> app;</div><div class="line"><span class="keyword">let</span> user1: User = (app = &#123;</div><div class="line">    name: <span class="string">"ccc"</span>,</div><div class="line">    card: <span class="string">"d"</span>,</div><div class="line">    <span class="built_in">number</span>: <span class="number">1</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//Error: card属性不存在User类型里面</span></div><div class="line"><span class="built_in">console</span>.log(user1.card);</div></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app;</div><div class="line"><span class="keyword">var</span> user1 = (app = &#123;</div><div class="line">    name: <span class="string">"ccc"</span>,</div><div class="line">    card: <span class="string">"d"</span>,</div><div class="line">    number: <span class="number">1</span></div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(user1.card);<span class="comment">// "d"</span></div></pre></td></tr></table></figure><p>虽然声明user1对象时，没有报错，但是使用除了name和id之外的属性时，会报错，这里看到app对象<strong>绕过</strong>了User的类型检查，但是强制翻译ts文件（不推荐这么做），可以得到<code>user1.card</code>的值为d,虽然typescript在类型检查阶段报错了，但是并不程序影响正确执行</p><h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>当不希望属性的值被更改时，可以设置属性可读。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> User&#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    readonly id: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> user1:User = &#123;</div><div class="line">    name: <span class="string">"jack"</span>,</div><div class="line">    id: <span class="number">4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">user1.id = <span class="number">1</span>;<span class="comment">//错误：无法对id赋值因为它是一个只读属性。</span></div></pre></td></tr></table></figure><p>检查条件为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">"id"</span>, &#123;</div><div class="line">        writable: <span class="literal">false</span>,</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> obj === &#123;&#125; &amp;&amp; obj.name !== <span class="literal">undefined</span> &amp;&amp; obj.id !== <span class="literal">undefined</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="额外的属性检查-对象字面量和数组"><a href="#额外的属性检查-对象字面量和数组" class="headerlink" title="额外的属性检查(对象字面量和数组)"></a>额外的属性检查(对象字面量和数组)</h3><p>由于JavaScript的动态性，可以先声明对象，在添加属性，typescript为了实现这一特性，添加了额外的属性检查，这允许动态添加属性。对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Card&#123;</div><div class="line">    readonly id: <span class="built_in">number</span>;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> card:Card = &#123;</div><div class="line">    name: <span class="string">"jack"</span>,</div><div class="line">    id: <span class="number">4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">card.size = <span class="number">20</span>;</div><div class="line">card.price = <span class="string">`$1`</span>;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> StringArray &#123;</div><div class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> myArray: StringArray = [<span class="string">"Bob"</span>, <span class="string">"Fred"</span>];</div><div class="line">myArray.push(<span class="string">"Alice"</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</div></pre></td></tr></table></figure><p>需要注意的地方是对象所有属性的<code>key</code>为string类型，<code>value</code>为string或者number类型。</p><h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><h3 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h3><p>面向对象编程中最重要的实现是类，如何用接口去约束类，是typescript检查的重点。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> ClockInterface &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    getTime() : <span class="built_in">Date</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">    getTime() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.currentTime;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里简单的声明了一个接口，实现接口的类必须要有一个属性currentTime为Date类型,一个方法叫做<code>getTime</code>并返回一个Date类型的值。</p><p>当你操作类和接口的时候，你要知道类（类是由函数模拟而来）是具有两个类型的：静态部分的类型（存在于函数的属性上）和实例的类型（存在于函数的原型链上）。因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不能检查构造函数</span></div><div class="line"><span class="keyword">interface</span> ClockConstructor &#123;</div><div class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</div><div class="line">    currentTime: <span class="built_in">Date</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 构造函数通过函数来检查</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params">ctor: ClockConstructor, h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>): <span class="title">ClockConstructor</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(h: <span class="built_in">number</span>, m: <span class="built_in">number</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Point&#123;</div><div class="line">    x: <span class="built_in">number</span>;</div><div class="line">    y: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> ThreePoint <span class="keyword">extends</span> Point&#123;</div><div class="line">    z: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> point: ThreePoint = &#123;</div><div class="line">    x: <span class="number">0</span>,</div><div class="line">    y: <span class="number">0</span>,</div><div class="line">    z: <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>前面说到typescript为结构性子类型化，可以看到接口threePoint的检查类型比接口Point的更严格，在检查x,y的属性上额外添加了对z的属性检查。</p><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Box &#123;</div><div class="line">    <span class="keyword">private</span> state: <span class="built_in">boolean</span>;</div><div class="line">    pick() &#123; &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> selectBox <span class="keyword">extends</span> Box &#123;</div><div class="line">    select(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Error: Property 'state' is private in type 'selectBox' but not in type 'textForm'.</span></div><div class="line"><span class="keyword">class</span> textForm <span class="keyword">implements</span> selectBox &#123;</div><div class="line">    state: <span class="built_in">boolean</span>;</div><div class="line">    select() &#123;&#125;</div><div class="line">    pick() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Box <span class="keyword">implements</span> selectBox &#123;</div><div class="line">    select() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到Box类私有属性state被selectBox接口继承了,则会生成下面这个接口：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> selectBox &#123;</div><div class="line">    <span class="keyword">private</span> state: <span class="built_in">boolean</span>;</div><div class="line">    pick() &#123; &#125;;</div><div class="line">    select(): <span class="built_in">void</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>textForm类必须实现state，pick()方法,select()方法，由于state为私有属性，所以会报错。因为state是私有成员，所以只能Box的子类们才能实现selectBox接口，只有Box的子类才能够拥有一个声明于Box的私有成员state。</p><blockquote><p>无论父类中的成员变量是私有的、共有的、还是其它类型的，子类都会拥有父类中的这些成员变量。但是父类中的私有成员变量，无法在子类中直接访问，必须通过从父类中继承得到的protected、public方法（如getter、setter方法）来访问。这是因为子类对父类进行了<strong>屏蔽</strong>。</p></blockquote><h2 id="类与接口的关系"><a href="#类与接口的关系" class="headerlink" title="类与接口的关系"></a>类与接口的关系</h2><p>类型和接口之间有一对多和多对一的关系，下面将列举出这些常见的概念，以方便读者理解接口与类型在复杂环境下的实现关系。</p><h3 id="一个类实现多个接口"><a href="#一个类实现多个接口" class="headerlink" title="一个类实现多个接口"></a>一个类实现多个接口</h3><p>一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。</p><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个 Socket。Socket 能够同时读取和写入数据，这个特性与文件类似。因此，开发中把文件和 Socket 都具备的读写特性抽象为独立的读写器概念。Socket 和文件一样，在使用完毕后，也需要对资源进行释放。把 Socket 能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可被写入的抽象</span></div><div class="line"><span class="keyword">interface</span> Writer &#123;</div><div class="line">    write(p: Buffer): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 可被关闭的抽象</span></div><div class="line"><span class="keyword">interface</span> Closer &#123;</div><div class="line">    close(error?: <span class="built_in">Error</span>) : <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现两个接口</span></div><div class="line"><span class="keyword">class</span> Socket <span class="keyword">implements</span> Writer, Closer &#123;</div><div class="line">    writer: NodeJS.WriteStream;</div><div class="line">    write(data: Buffer): <span class="built_in">void</span> &#123;</div><div class="line">        <span class="keyword">this</span>.writer.write(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    close(error?: <span class="built_in">Error</span>): <span class="built_in">void</span> &#123;</div><div class="line">        <span class="keyword">this</span>.writer.destroy(error);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 使用Writer的代码, 并不知道Socket和iCloser的存在</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">usingWriter</span>(<span class="params">writer: Writer</span>) </span>&#123;</div><div class="line">    writer.write(<span class="keyword">new</span> Buffer(<span class="string">"Hello"</span>));</div><div class="line">&#125;</div><div class="line"><span class="comment">// 使用iCloser, 并不知道Socket和Writer的存在</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">usingCloser</span>(<span class="params">closer: Closer</span>) </span>&#123;</div><div class="line">    closer.close();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> s = <span class="keyword">new</span> Socket();</div><div class="line">    usingWriter(s);</div><div class="line">    usingCloser(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure><img src="/2019/09/06/typescript接口/图片1.png" alt="多个类实现一个接口" title="多个类实现一个接口"><p>socket 类实现了 writer 接口和 closer 接口，函数 usingWriter 不需要知道内部细节，只需要知道拥有write方法，函数在使用时传入一个实现了writer 接口的类型，无需关心其他，实现了调用与实现无关。</p><h3 id="多个类实现一个接口"><a href="#多个类实现一个接口" class="headerlink" title="多个类实现一个接口"></a>多个类实现一个接口</h3><p>一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。</p><p>Service 接口定义了两个方法：一个是开启服务的方法（Start()），一个是输出日志的方法（Log()）。使用 GameService 类来实现 Service，GameService 自己的结构只能实现 Start() 方法，而 Service 接口中的 Log() 方法已经被一个能输出日志的日志器（Logger）实现了，无须再进行 GameService 封装，或者重新实现一遍。所以，选择将 Logger 嵌入到 GameService 能最大程度地避免代码冗余，简化代码结构。详细实现过程如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个服务需要满足能够开启和写日志的功能</span></div><div class="line"><span class="keyword">interface</span> Service&#123;</div><div class="line">    Start()  <span class="comment">// 开启服务</span></div><div class="line">    Log(<span class="built_in">string</span>)  <span class="comment">// 日志输出</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 日志器</span></div><div class="line"><span class="keyword">class</span> Logger&#123;</div><div class="line">    <span class="comment">// 实现Service的Log()方法</span></div><div class="line">    Log(l: <span class="built_in">string</span>) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 游戏服务</span></div><div class="line"><span class="keyword">class</span> GameService <span class="keyword">extends</span> Logger &#123;</div><div class="line">    <span class="comment">// 实现Service的Start()方法</span></div><div class="line">    Start() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> s: Service = <span class="keyword">new</span> GameService();</div><div class="line">s.Start()</div><div class="line">s.Log(<span class="string">"Hello"</span>)</div></pre></td></tr></table></figure><img src="/2019/09/06/typescript接口/图片2.png" alt="多个类实现一个接口" title="多个类实现一个接口"><p>通过接口的方式，分离了接口内和接口外的环境，使得系统设计可以更加容易的分解。</p><h3 id="用接口实现一个排序系统"><a href="#用接口实现一个排序系统" class="headerlink" title="用接口实现一个排序系统"></a>用接口实现一个排序系统</h3><p>下面我们来用接口实现一个排序系统，简单的来说排序就是要遍历集合中的所有元素，比较元素之间的大小或某种次序，移动元素的相应的位置，使整个集合有序的操作。先定义出可排序的基本条件，可被遍历，大小比较，移动元素。声明一个排序接口如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Sort &#123;</div><div class="line">    <span class="comment">// 获取元素数量</span></div><div class="line">    Len(): <span class="built_in">number</span>;</div><div class="line">    <span class="comment">// 小于比较</span></div><div class="line">    Less(i: <span class="built_in">number</span>, j: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</div><div class="line">    <span class="comment">// 交换元素</span></div><div class="line">    Swap(i: <span class="built_in">number</span>, j: <span class="built_in">number</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>声明完接口之后，我们就可以对接口提供的逻辑进行使用了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里是一个简单的冒泡排序</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">data: Sort</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.Len(); i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; data.Len(); j++) &#123;</div><div class="line">            <span class="keyword">if</span> (data.Less(i, j)) &#123;</div><div class="line">                data.Swap(i, j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下一步就是实现接口，这是内部逻辑的填充，接口只是一个声明，无法执行相应的逻辑。在编译成 JavaScript 后，相应的接口也会被檫除。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个实现的是对字符串的排序</span></div><div class="line"><span class="keyword">class</span> MyStringList <span class="keyword">implements</span> Sort &#123;</div><div class="line">    <span class="comment">// 声明字符串数组</span></div><div class="line">    List: <span class="built_in">string</span>[];</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">List: <span class="built_in">string</span>[]</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.List = List;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 获取字符串数组的长度</span></div><div class="line">    Len() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.List.length;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 字符串大小比较的规则</span></div><div class="line">    Less(i: <span class="built_in">number</span>, j: <span class="built_in">number</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.List[i] &lt; <span class="keyword">this</span>.List[j];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 交换</span></div><div class="line">    Swap(i: <span class="built_in">number</span>, j: <span class="built_in">number</span>) &#123;</div><div class="line">        [<span class="keyword">this</span>.List[i], <span class="keyword">this</span>.List[j]] = [<span class="keyword">this</span>.List[j], <span class="keyword">this</span>.List[i]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>所有的工作都已经做完了，下面我们来测试一下实际效果。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> names = <span class="keyword">new</span> MyStringList([</div><div class="line">    <span class="string">"3. three sheep"</span>,</div><div class="line">    <span class="string">"5. five sheep"</span>,</div><div class="line">    <span class="string">"2. two sheep"</span>,</div><div class="line">    <span class="string">"4. four sheep"</span>,</div><div class="line">    <span class="string">"1. one sheep"</span></div><div class="line">]);</div><div class="line"></div><div class="line">sort(names);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(names);</div></pre></td></tr></table></figure><p>很好地完成了排序工作，现在这里有一个数组，同样也需要排序。现在不比费心去重新去写一遍，在原来排序接口的接口上添加数组的排序逻辑即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组实现排序的接口</span></div><div class="line"><span class="keyword">class</span> myArray <span class="keyword">implements</span> Sort &#123;</div><div class="line">    List: <span class="built_in">number</span>[];</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">List: <span class="built_in">number</span>[]</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.List = List;</div><div class="line">    &#125;</div><div class="line">    Len() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.List.length;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 注意这里虽然逻辑相同，但是数字大小的比较，而上面是字符串的比较</span></div><div class="line">    Less(i: <span class="built_in">number</span>, j: <span class="built_in">number</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.List[i] &lt; <span class="keyword">this</span>.List[j];</div><div class="line">    &#125;</div><div class="line">    Swap(i: <span class="built_in">number</span>, j: <span class="built_in">number</span>) &#123;</div><div class="line">        [<span class="keyword">this</span>.List[i], <span class="keyword">this</span>.List[j]] = [<span class="keyword">this</span>.List[j], <span class="keyword">this</span>.List[i]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同样地检测一下排序效果，给定一个数组。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> myArray([<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]);</div><div class="line">sort(list);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(list);</div></pre></td></tr></table></figure><p>现在我们把排序的概念延伸一下，上面的排序系统不仅能排序数组和字符串数组这种简单的数据结构，还能排序其他的数据结构，比如常见的对象。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明军队的分类</span></div><div class="line"><span class="keyword">enum</span> ArmyKind&#123;</div><div class="line">    None = <span class="number">1</span>,</div><div class="line">    Air,</div><div class="line">    Sea,</div><div class="line">    land</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义一个军队</span></div><div class="line"><span class="keyword">class</span> Army &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    kind: ArmyKind;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name : <span class="built_in">string</span>, kind : <span class="built_in">number</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.kind = kind;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现排序逻辑</span></div><div class="line"><span class="keyword">class</span> Armies <span class="keyword">implements</span> Sort &#123;</div><div class="line">    armyList: Army[];</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">armyList: Army[]</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.armyList = armyList;</div><div class="line">    &#125;</div><div class="line">    Len() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.armyList.length;</div><div class="line">    &#125;</div><div class="line">    Less(i: <span class="built_in">number</span>, j: <span class="built_in">number</span>) &#123;</div><div class="line">        <span class="keyword">let</span> s = <span class="keyword">this</span>.armyList;</div><div class="line">        <span class="comment">// 如果军队的分类不一致时, 优先对分类进行排序</span></div><div class="line">        <span class="keyword">if</span> (s[i].kind != s[j].kind) &#123;</div><div class="line">            <span class="keyword">return</span> s[i].kind &lt; s[j].kind;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 默认按军队名字字符升序排列</span></div><div class="line">        <span class="keyword">return</span> s[i].name &lt; s[j].name;</div><div class="line">    &#125;</div><div class="line">    Swap(i: <span class="built_in">number</span>, j: <span class="built_in">number</span>) &#123;</div><div class="line">        <span class="keyword">let</span> s = <span class="keyword">this</span>.armyList;</div><div class="line">        [s[i], s[j]] = [s[j], s[i]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面看看效果会怎么样，给出一个<code>Armies</code>类的实例。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> armies = <span class="keyword">new</span> Armies([</div><div class="line">    <span class="keyword">new</span> Army(<span class="string">"A3"</span>, ArmyKind.Air),</div><div class="line">    <span class="keyword">new</span> Army(<span class="string">"A8"</span>, ArmyKind.Air),</div><div class="line">    <span class="keyword">new</span> Army(<span class="string">"S1"</span>, ArmyKind.Sea),</div><div class="line">    <span class="keyword">new</span> Army(<span class="string">"S4"</span>, ArmyKind.Sea),</div><div class="line">    <span class="keyword">new</span> Army(<span class="string">"L2"</span>, ArmyKind.land)</div><div class="line">]);</div><div class="line"><span class="comment">// 使用sort包进行排序</span></div><div class="line">sort(armies);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(armies);</div></pre></td></tr></table></figure><p>MyStringList、MyArray和Armies类都实现了sort接口，可见他们有一种共性。这种共性抽象出了一个Sort概念（可被排序的基本要求），接下来用MyStringList、MyArray和Armies类去实现sort接口的要求，使得提供len、less和swap方法的类就可以被排序。</p><p>在排序算法中使用Sort接口即可完成排序，无需关心其实现，直接与MyStringList、MyArray和Armies类提供的上层抽象sort相关联。调用时，只要传入MyStringList、MyArray和Armies类的实例即可。同样抽象类也可以，MyStringList、MyArray和Armies类都继承同一个抽象类，排序算法算法直接与抽象类打交道。当然还有更高效的排序算法，这里就不一一列举了。</p><p>这样抽象就建立起来了，通过抽象类和接口去描述抽象，使得系统设计可以更加容易的分解和解耦，为大型系统的设计铺路。</p><h2 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h2><p>对于面向对象编程来说，<strong>抽象</strong>是它的一大特征之一。在面对对象的语言Java中，可以通过两种形式来体现OOP的抽象：接口和抽象类。这两者有太多相似的地方，又有太多不同的地方。typescript同样也实现了接口和抽象类，两种语言的概念差别不大。</p><p>抽象类是什么：</p><blockquote><p>抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类的随意性。抽象类不能创建实例，它只能作为父类被继承。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Book &#123;</div><div class="line">    pages: Page[];</div><div class="line">    currentPage = <span class="number">0</span>;</div><div class="line">    open(pageNumber: <span class="built_in">number</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pages.filter(<span class="function"><span class="params">value</span> =&gt;</span> value.page = pageNumber);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    close() &#123;</div><div class="line">        <span class="keyword">this</span>.currentPage = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.pages[<span class="keyword">this</span>.currentPage];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Page&#123;</div><div class="line">    page = <span class="number">0</span>;</div><div class="line">    content = <span class="string">""</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">page: <span class="built_in">number</span>, content: <span class="built_in">string</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.page = page;</div><div class="line">        <span class="keyword">this</span>.content = content;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> mathBook <span class="keyword">extends</span> Book &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, pages: Page[]</span>) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.pages = pages;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> math = <span class="keyword">new</span> mathBook(<span class="string">"math"</span>, [</div><div class="line">    <span class="keyword">new</span> Page(<span class="number">1</span>, <span class="string">"3 + 5"</span>),</div><div class="line">    <span class="keyword">new</span> Page(<span class="number">2</span>, <span class="string">" 3 - 1"</span>),</div><div class="line">    <span class="keyword">new</span> Page(<span class="number">3</span>, <span class="string">" 3 * 2"</span>),</div><div class="line">    <span class="keyword">new</span> Page(<span class="number">4</span>, <span class="string">" 9 / 3"</span>),</div><div class="line">]);</div><div class="line">math.open(<span class="number">3</span>);</div><div class="line">math.close();</div><div class="line"></div><div class="line"><span class="keyword">class</span> englishBook <span class="keyword">extends</span> Book &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, pages: Page[]</span>) &#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.pages = pages;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> english = <span class="keyword">new</span> englishBook(<span class="string">"english"</span>, [</div><div class="line">    <span class="keyword">new</span> Page(<span class="number">1</span>, <span class="string">"hello"</span>),</div><div class="line">    <span class="keyword">new</span> Page(<span class="number">2</span>, <span class="string">"china"</span>),</div><div class="line">    <span class="keyword">new</span> Page(<span class="number">3</span>, <span class="string">"food"</span>),</div><div class="line">    <span class="keyword">new</span> Page(<span class="number">4</span>, <span class="string">"weather"</span>),</div><div class="line">])</div><div class="line"></div><div class="line">english.open(<span class="number">2</span>);</div><div class="line">english.close();</div></pre></td></tr></table></figure><p>抽象类<code>Book</code>封装了书的概念，书可以被打开和关闭，数学书和英语书继承了书的概念，符合我们现实生活中的观点。</p><p>接口是什么：</p><blockquote><p>接口本身是一种对行为的一种抽象，实现接口的类将按照接口的规范约束行为。我们开发中经常说给别人提供接口，而不是说给别人提供实现类。我们将属性私有，通过接口中的行为来操作。这样封装了内部的实现。当我们对外提供接口，而不是直接暴露实现类，这样调用的类就实现了与提供类之间的解耦。</p></blockquote><figure class="highlight ts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Open&#123;</div><div class="line">    open(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Door <span class="keyword">implements</span> Open&#123;</div><div class="line">   <span class="keyword">private</span> closed = <span class="literal">true</span>;</div><div class="line">    open() &#123;</div><div class="line">        <span class="keyword">this</span>.closed = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    close() &#123;</div><div class="line">        <span class="keyword">this</span>.closed = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Computer <span class="keyword">implements</span> Open&#123;</div><div class="line">    open() &#123;</div><div class="line">        <span class="keyword">this</span>.setup();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> setup() &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"hello world"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> door: Open = <span class="keyword">new</span> Door();</div><div class="line">door.open();</div><div class="line"></div><div class="line"><span class="keyword">let</span> mac: Open = <span class="keyword">new</span> Computer();</div><div class="line">mac.open();</div></pre></td></tr></table></figure><p>上面的两个类<code>Door</code>和<code>Computer</code>很难有共同特点，但是有一个<code>open</code>方法，使用抽象类固然可以，但是一个功能一个继承，多重继承会带来很多麻烦，使用接口能更加细粒度地描述抽象，即接口比抽象类更加抽象和灵活，细数两者之间的区别：</p><ol><li>抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract方法；</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://c.biancheng.net/view/79.html" target="_blank" rel="external">Go语言类型与接口的关系</a></p><p><a href="http://c.biancheng.net/view/81.html" target="_blank" rel="external">Go语言排序</a></p><p><a href="https://blog.csdn.net/universe_ant/article/details/59491738" target="_blank" rel="external">深入理解Java的接口和抽象类</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机中，接口是计算机系统中两个独立的部件进行信息交换的共享边界。这种交换可以发生在计算机软、硬件，外部设备或进行操作的人之间，也可以是它们的结合。&lt;br&gt;Typescript通过类型检查的方式减少了程序犯错误的机率，但是不能约束代码的产出方式，模块暴露出的API变更之后会产生一系列的麻烦。在TypeScript里，接口的作用就是规范代码，为需要约束的类型命名和为你的代码或第三方代码定义产出方式。因为typescript认为约束条件一样时是属于同一类，所以它有时被称做“鸭式辨型法”或“结构性子类型化”。&lt;/p&gt;
&lt;h2 id=&quot;具名接口&quot;&gt;&lt;a href=&quot;#具名接口&quot; class=&quot;headerlink&quot; title=&quot;具名接口&quot;&gt;&lt;/a&gt;具名接口&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;interface&lt;/code&gt;关键词为&lt;strong&gt;约束条件&lt;/strong&gt;添加名字，主要为对象和函数添加约束，利用typescript中提到的类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;symbol&lt;/li&gt;
&lt;li&gt;array&lt;/li&gt;
&lt;li&gt;function&lt;/li&gt;
&lt;li&gt;object&lt;/li&gt;
&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;any&lt;/li&gt;
&lt;li&gt;void&lt;/li&gt;
&lt;li&gt;tuple&lt;/li&gt;
&lt;li&gt;unknown&lt;/li&gt;
&lt;li&gt;never&lt;/li&gt;
&lt;li&gt;字面量类型&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;对象的接口&quot;&gt;&lt;a href=&quot;#对象的接口&quot; class=&quot;headerlink&quot; title=&quot;对象的接口&quot;&gt;&lt;/a&gt;对象的接口&lt;/h3&gt;&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; User&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; Car&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; user: User = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;lily&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; car: Car = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;tick&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getUserName&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;user: User&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; user.name;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;getUserName(car);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数getUserName限制传入参数为User类，可是我们传入了一个Car类，并且没有报错，这是为什么呢？User类的约束条件为&lt;code&gt;function test(obj) { return obj === {} &amp;amp;&amp;amp; obj.name !== undefined &amp;amp;&amp;amp; obj.id !== undefined;}&lt;/code&gt;,同时Car类的约束条件也是一样的，所以函数可以传入Car类，所以typescript有时被称做“鸭式辨型法”或“结构性子类型化”。&lt;/p&gt;
&lt;h3 id=&quot;函数的接口&quot;&gt;&lt;a href=&quot;#函数的接口&quot; class=&quot;headerlink&quot; title=&quot;函数的接口&quot;&gt;&lt;/a&gt;函数的接口&lt;/h3&gt;&lt;p&gt;为函数添加约束条件，约束函数的传入参数和返回值，与第四章添加函数的类型检查时一样。&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; isArray&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    (array: []): &lt;span class=&quot;built_in&quot;&gt;boolean&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; isArray : isArray = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;array: []&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.prototype.toString.call(array) === &lt;span class=&quot;string&quot;&gt;&#39;[object Array]&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;属性的约束&quot;&gt;&lt;a href=&quot;#属性的约束&quot; class=&quot;headerlink&quot; title=&quot;属性的约束&quot;&gt;&lt;/a&gt;属性的约束&lt;/h2&gt;&lt;p&gt;检查对象的属性分为必须、可选、只读，函数的参数有必须、可选之分&lt;/p&gt;
&lt;h3 id=&quot;可选属性&quot;&gt;&lt;a href=&quot;#可选属性&quot; class=&quot;headerlink&quot; title=&quot;可选属性&quot;&gt;&lt;/a&gt;可选属性&lt;/h3&gt;&lt;p&gt;有时候不确定某个属性是否存在时，在声明的属性后面加入一个&lt;code&gt;?&lt;/code&gt;，就可以使属性变得可选。&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; User&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id?: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; user: User = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;boy&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; user1:User = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&quot;jack&quot;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createUser&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;, id?: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        name: name,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;检查条件为&lt;code&gt;function test(obj) { return (obj === {} &amp;amp;&amp;amp; obj.name !== undefined &amp;amp;&amp;amp; obj.id !== undefined;) || obj === {} &amp;amp;&amp;amp; obj.id !== undefined;}&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="typescript 接口" scheme="https://hqiwen.github.io/tags/typescript-%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之排序</title>
    <link href="https://hqiwen.github.io/2019/03/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%8E%92%E5%BA%8F/"/>
    <id>https://hqiwen.github.io/2019/03/10/数据结构之排序/</id>
    <published>2019-03-10T03:27:57.000Z</published>
    <updated>2019-03-10T06:15:02.730Z</updated>
    
    <content type="html"><![CDATA[<p>排序就是将一组对象按照某种逻辑重新排列的过程。</p><h2 id="初级排序算法"><a href="#初级排序算法" class="headerlink" title="初级排序算法"></a>初级排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>不断重复找到最小的元素，移到相应位置。{0-N} = {0, 1, 2,..N}, {n} = swap( nums[n], min{ nums[n~nums.length] } )</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i&lt; nums.length; i++) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &lt; nums.length; j++) &#123;</div><div class="line">        minNum = min(minNum, nums[j]);</div><div class="line">    &#125;</div><div class="line">    swap(minNum, nums[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>有 N 次交换和N+(N-1)+..+2+1~N^2/2次比较</p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>每次将一个数插入有序数组的适当位置。{0-N} = {0, 1, 2,..N},{n} = { nums[0~n]}.swap( less(nums[n], nums[n-1]) )</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length; i++) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j &gt;<span class="number">0</span>; j--)&#123;</div><div class="line">        <span class="keyword">if</span>(num[j] &lt; nums[j<span class="number">-1</span>]) &#123;</div><div class="line">            swap(nums[j], nums[j<span class="number">-1</span>]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>插入排序所需的时间与输入的元素的初始顺序有关，最坏情况下需要N^2/2次比较和N^2/2次交换，最好需要N-1次比较和0次交换<br><a id="more"></a></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>要将一个数组排序，可以递归地将它分成两半分别排序，然后在合并起来。{0-N} = merge( {0-N/2},  {N/2-N} );<br>merge(n) = { min( {0-n/2}, {n/2-n} ) }。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums, lo, hi</span>) </span>&#123;</div><div class="line">   <span class="keyword">let</span>  mid = (lo + hi ) / <span class="number">2</span>;</div><div class="line">    sort(nums, lo, mid);</div><div class="line">    sort(nums, mid+<span class="number">1</span>, hi);</div><div class="line">    merge(nums,lo, mid, hi);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">nums, low, mid, high</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> i = lo, j = mid +<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k = lo; k &lt;= high, k++) &#123;</div><div class="line">        aux[k] = nums[k];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> k =lo; k&lt;=high;k++) &#123;</div><div class="line">        <span class="keyword">if</span>(i&gt;mid) a[k] = aux[j++];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(less(aux[j], aux[k])) a[k] = aux[j++];</div><div class="line">        <span class="keyword">else</span> a[k] = aux[i++];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度NlgN,空间复杂度N,比初级算法较优</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>当两个子数组有序时，就完成了排序。{0-N} = {0-K} + {K-N};partition(n) = swap( n1&lt;k, k&lt;n2 ),k = nums[lo]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">nums, lo, hi</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> j = partition(nums,lo, hi);</div><div class="line">    sort(nums, lo, j<span class="number">-1</span>);</div><div class="line">    sort(nums, j+<span class="number">1</span>, hi);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">nums, lo ,hi</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> i = lo, j = hi, k = nums[lo];</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">while</span>(a[++i] &lt; k) <span class="keyword">if</span>(i = hi) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">while</span>(a[++j] &gt; k) <span class="keyword">if</span>(j = lo) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(i&gt;j) <span class="keyword">break</span>;</div><div class="line">        swap(nums[i], nums[j]);</div><div class="line">    &#125;</div><div class="line">    swap(nums[lo], nums[j]);</div><div class="line">    <span class="keyword">return</span> j;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>时间复杂度NlgN,空间复杂度lgN</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序就是将一组对象按照某种逻辑重新排列的过程。&lt;/p&gt;
&lt;h2 id=&quot;初级排序算法&quot;&gt;&lt;a href=&quot;#初级排序算法&quot; class=&quot;headerlink&quot; title=&quot;初级排序算法&quot;&gt;&lt;/a&gt;初级排序算法&lt;/h2&gt;&lt;h3 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h3&gt;&lt;p&gt;不断重复找到最小的元素，移到相应位置。{0-N} = {0, 1, 2,..N}, {n} = swap( nums[n], min{ nums[n~nums.length] } )&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i =&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i&amp;lt; nums.length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; j = i; j &amp;lt; nums.length; j++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        minNum = min(minNum, nums[j]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    swap(minNum, nums[i]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;有 N 次交换和N+(N-1)+..+2+1~N^2/2次比较&lt;/p&gt;
&lt;h3 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h3&gt;&lt;p&gt;每次将一个数插入有序数组的适当位置。{0-N} = {0, 1, 2,..N},{n} = { nums[0~n]}.swap( less(nums[n], nums[n-1]) )&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;i&amp;lt;nums.length; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; j = i; j &amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j--)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num[j] &amp;lt; nums[j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            swap(nums[j], nums[j&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;插入排序所需的时间与输入的元素的初始顺序有关，最坏情况下需要N^2/2次比较和N^2/2次交换，最好需要N-1次比较和0次交换&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://hqiwen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组 排序" scheme="https://hqiwen.github.io/tags/%E6%95%B0%E7%BB%84-%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>web服务器框架原理</title>
    <link href="https://hqiwen.github.io/2019/03/10/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/"/>
    <id>https://hqiwen.github.io/2019/03/10/web服务器框架原理/</id>
    <published>2019-03-10T02:22:36.000Z</published>
    <updated>2019-03-10T02:32:53.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>通过一个数组收集中间件，然后通过算法让其依次执行，平常所写的业务代码被收集起来，交给框架去最优化运行</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> app = &#123;</div><div class="line">    stacks: [];</div><div class="line">&#125;;</div><div class="line"><span class="comment">//监听http请求</span></div><div class="line">app.listen = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> server = http.createServer(app.callback);</div><div class="line">    <span class="keyword">return</span> server.listen(...args);</div><div class="line">&#125;;</div><div class="line"><span class="built_in">module</span>.exports = app;</div></pre></td></tr></table></figure><h3 id="实例收集"><a href="#实例收集" class="headerlink" title="实例收集"></a>实例收集</h3><p>通过app.use收集要使用的中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">app.use = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> fn === <span class="string">"function"</span>)&#123;</div><div class="line">        <span class="keyword">throw</span>(<span class="string">'middleware must be a function'</span>)</div><div class="line">    &#125;</div><div class="line">    app.stacks.push(fn);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="算法与运行时"><a href="#算法与运行时" class="headerlink" title="算法与运行时"></a>算法与运行时</h3><p>数组的链式调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">app.callback = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">    dispatch(req, res, app.stacks);</div><div class="line">&#125;</div><div class="line"><span class="comment">//每当有请求传来，就调用中间件数组</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">req, res, stack</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> next = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">            <span class="keyword">return</span> handleError(err, req, res, stack);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">let</span> middleware = stack.shift();</div><div class="line">        <span class="keyword">if</span> (middleware) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//next传递给下一个中间件，形成尾调用</span></div><div class="line">                middleware(req, res, next);</div><div class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">                next(err);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    next();</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件是一个函数，function(req, res, next),<em>req</em>是IncomingMessage对象，<em>res</em>是ServerResponse对象,next函数调用下一个中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> query =  <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> opts = merge(&#123;&#125;, options);</div><div class="line">    <span class="keyword">var</span> queryparse = qs.parse;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">"function"</span>) &#123;</div><div class="line">        queryparse = options;</div><div class="line">        opts = <span class="literal">undefined</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">req, res, next</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!req.query) &#123;</div><div class="line">            <span class="keyword">var</span> val = url.parse(req.url).query;</div><div class="line">            req.query = queryparse(val, opts);</div><div class="line">        &#125;</div><div class="line">        next();</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">app.use(query());</div></pre></td></tr></table></figure><a id="more"></a><h3 id="req-和-res-对象的增强"><a href="#req-和-res-对象的增强" class="headerlink" title="req 和 res 对象的增强"></a>req 和 res 对象的增强</h3><p>node 本身的 http 模块不能很好地适应业务需求，需要对其改造</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> req = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">//req.headers, req.socket, req.method</span></div><div class="line"><span class="keyword">let</span> res = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">//res.sendFile, res.json, res.render, res.redirect</span></div><div class="line"></div><div class="line">app.request = req;</div><div class="line">app.response = res;</div></pre></td></tr></table></figure><h2 id="mvc模式"><a href="#mvc模式" class="headerlink" title="mvc模式"></a>mvc模式</h2><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// let tpl = 'hello &lt;%=username%&gt;.'  render(tpl, &#123;username: "jack"&#125;)</span></div><div class="line"> <span class="keyword">let</span> tpl = str.replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</div><div class="line">     <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;code&#125;</span>`</span>;</div><div class="line"> &#125;)</div><div class="line"></div><div class="line"> res.render = <span class="function"><span class="keyword">function</span>(<span class="params">viewName, data</span>) </span>&#123;&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;通过一个数组收集中间件，然后通过算法让其依次执行，平常所写的业务代码被收集起来，交给框架去最优化运行&lt;/p&gt;
&lt;h3 id=&quot;命名空间&quot;&gt;&lt;a href=&quot;#命名空间&quot; class=&quot;headerlink&quot; title=&quot;命名空间&quot;&gt;&lt;/a&gt;命名空间&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; app = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    stacks: [];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//监听http请求&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;app.listen = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;...args&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; server = http.createServer(app.callback);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; server.listen(...args);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.exports = app;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;实例收集&quot;&gt;&lt;a href=&quot;#实例收集&quot; class=&quot;headerlink&quot; title=&quot;实例收集&quot;&gt;&lt;/a&gt;实例收集&lt;/h3&gt;&lt;p&gt;通过app.use收集要使用的中间件&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;app.use = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;fn&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; fn === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;middleware must be a function&#39;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    app.stacks.push(fn);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;算法与运行时&quot;&gt;&lt;a href=&quot;#算法与运行时&quot; class=&quot;headerlink&quot; title=&quot;算法与运行时&quot;&gt;&lt;/a&gt;算法与运行时&lt;/h3&gt;&lt;p&gt;数组的链式调用&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;app.callback = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;req, res&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    dispatch(req, res, app.stacks);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//每当有请求传来，就调用中间件数组&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;dispatch&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;req, res, stack&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; next = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (err) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; handleError(err, req, res, stack);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; middleware = stack.shift();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (middleware) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;//next传递给下一个中间件，形成尾调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                middleware(req, res, next);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (err) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                next(err);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    next();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;中间件&quot;&gt;&lt;a href=&quot;#中间件&quot; class=&quot;headerlink&quot; title=&quot;中间件&quot;&gt;&lt;/a&gt;中间件&lt;/h3&gt;&lt;p&gt;中间件是一个函数，function(req, res, next),&lt;em&gt;req&lt;/em&gt;是IncomingMessage对象，&lt;em&gt;res&lt;/em&gt;是ServerResponse对象,next函数调用下一个中间件&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; query =  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;options&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; opts = merge(&amp;#123;&amp;#125;, options);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; queryparse = qs.parse;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; options === &lt;span class=&quot;string&quot;&gt;&quot;function&quot;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        queryparse = options;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        opts = &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;query&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;req, res, next&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!req.query) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; val = url.parse(req.url).query;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            req.query = queryparse(val, opts);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        next();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;app.use(query());&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="web server express" scheme="https://hqiwen.github.io/tags/web-server-express/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统构造第二期</title>
    <link href="https://hqiwen.github.io/2018/11/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9E%84%E9%80%A0%E7%AC%AC%E4%BA%8C%E6%9C%9F/"/>
    <id>https://hqiwen.github.io/2018/11/16/计算机系统构造第二期/</id>
    <published>2018-11-16T11:04:41.000Z</published>
    <updated>2018-11-23T08:47:50.012Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块化、对象和状态"><a href="#模块化、对象和状态" class="headerlink" title="模块化、对象和状态"></a>模块化、对象和状态</h2><p>我们关于世界的常规观点之一，就是将它看作聚集在一起的许多独立对象，每个对象都有自己随着时间变化的状态。所谓一个对象有<strong>状态</strong>，也就是说<strong>它的行为受到它的历史的影响</strong>。</p><h3 id="赋值与局部状态"><a href="#赋值与局部状态" class="headerlink" title="赋值与局部状态"></a>赋值与局部状态</h3><p>假定开始账户里有100元钱，在不断使用withdraw的过程中可以得到以下响应序列：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">withdraw(<span class="number">25</span>) <span class="comment">// 75</span></div><div class="line">withdraw(<span class="number">25</span>) <span class="comment">// 50</span></div><div class="line">withdraw(<span class="number">60</span>) <span class="comment">//余额不足</span></div></pre></td></tr></table></figure><p>可以看到每次执行withdraw的结果不同，我们用一个变量balance去表示账户里的现金余额</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> balance = <span class="number">100</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">amount</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(amount &gt; balance)&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"余额不足"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        balance -= amount;</div><div class="line">        <span class="built_in">console</span>.log(balance);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">withdraw(<span class="number">50</span>);<span class="comment">// 50</span></div><div class="line">withdraw(<span class="number">20</span>);<span class="comment">// 30</span></div><div class="line">withdraw(<span class="number">20</span>);<span class="comment">// 10</span></div><div class="line">----------------------------------</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_withdraw</span>(<span class="params">amount</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> balance = <span class="number">100</span>;</div><div class="line">    <span class="keyword">if</span> (amount &gt; balance) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"余额不足"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        balance -= amount;</div><div class="line">        <span class="built_in">console</span>.log(balance);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> balance;</div><div class="line">&#125;;</div><div class="line">w1 = new_withdraw(<span class="number">50</span>);<span class="comment">// 50</span></div><div class="line">w2 = new_withdraw(<span class="number">20</span>);<span class="comment">// 80</span></div><div class="line">w3 = new_withdraw(<span class="number">20</span>);<span class="comment">// 80</span></div></pre></td></tr></table></figure><p>可以看到w1、w2、w3是各自独立的，互不影响，与所有状态都必须显式地操作和传递额外参数的方式相比，通过引进赋值和将状态隐藏在局部变量中的技术，我们能以一种更模块化的方式构造系统。<br><a id="more"></a></p><h3 id="按值传递和按引用传递"><a href="#按值传递和按引用传递" class="headerlink" title="按值传递和按引用传递"></a>按值传递和按引用传递</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> apple = &#123; <span class="attr">fruit</span>: <span class="string">"apple"</span> &#125;;</div><div class="line">    <span class="built_in">console</span>.log(apple.fruit);<span class="comment">//apple</span></div><div class="line">    <span class="keyword">let</span> banana = apple;</div><div class="line">    banana.fruit = <span class="string">"banana"</span>;</div><div class="line">    <span class="built_in">console</span>.log(apple.fruit);<span class="comment">//banana</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>变量是按引用传递的，apple.fruit的值会被修改，banana 复制了 apple的指向内存，两者共用一个内存，所以apple.fruit的值会被修改，因为变量保存的是指针，所以变量的值有暂时记忆。</p><h3 id="用变动的数据做模拟"><a href="#用变动的数据做模拟" class="headerlink" title="用变动的数据做模拟"></a>用变动的数据做模拟</h3><p>比如保存上一次的看的书的位置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> book = &#123;</div><div class="line">    name: name,</div><div class="line">    chapter: number,</div><div class="line">    page: number,</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">store</span>(<span class="params">name, chapter, page</span>) </span>&#123;</div><div class="line">    book.name = name,</div><div class="line">    book.chapter = chapter,</div><div class="line">    book.page = page,</div><div class="line">&#125;</div><div class="line">store(<span class="string">"CSS世界"</span>, <span class="number">1</span>, <span class="number">13</span>);</div></pre></td></tr></table></figure><h2 id="并发-本质上是时间问题"><a href="#并发-本质上是时间问题" class="headerlink" title="并发:本质上是时间问题"></a>并发:本质上是时间问题</h2><p>现实世界的对象并不是一次一个地顺序变化，与此相反，它们总是并发地活动，所有东西一起活动。所以用并发执行的计算进程模拟各种系统是正常的。从表面上看，时间似乎是非常简单的东西。它也就是强加在各种事件上的一个顺序。</p><h3 id="共享变量的处理"><a href="#共享变量的处理" class="headerlink" title="共享变量的处理"></a>共享变量的处理</h3><p>如果小明和小红要借阅同一本书，登录图书系统，则谁会借到这本书？</p><ol><li>如果小明先申请，这时小红也提出申请，服务器先写入小明的名字，当读取时被小红的写入改变，最后返回小红的名字，反而小红借到了这本书。</li><li>如果小明先申请，这时小红也提出申请，由于小明网络延时，服务器先返回小红的请求，反而小红借到了这本书。</li></ol><p>如何让小明借到这本书？</p><blockquote><p>方案一： 同时只让一个人提出申请，当一个人处于申请这本书状态时，不让其他人提出申请，严格限制请求，先到先得<br>方案二： 使用互斥锁，先获取先到的请求，忽略其他请求，竞争性互斥，具有不确定</p></blockquote><p>在并发系统的设计中，需要去<strong>控制不同进程访问共享变量的事件发生顺序</strong>，可以通过限定修改任意共享变量的两个操作都不允许同时发生，但是这样太低效和保守了；另一种保证并发系统产出的结果与各个进程按照某种方式顺序运行产生的结果完全一样，但是<strong>顺序不确定</strong>,常用互斥锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模块化、对象和状态&quot;&gt;&lt;a href=&quot;#模块化、对象和状态&quot; class=&quot;headerlink&quot; title=&quot;模块化、对象和状态&quot;&gt;&lt;/a&gt;模块化、对象和状态&lt;/h2&gt;&lt;p&gt;我们关于世界的常规观点之一，就是将它看作聚集在一起的许多独立对象，每个对象都有自己随着时间变化的状态。所谓一个对象有&lt;strong&gt;状态&lt;/strong&gt;，也就是说&lt;strong&gt;它的行为受到它的历史的影响&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;赋值与局部状态&quot;&gt;&lt;a href=&quot;#赋值与局部状态&quot; class=&quot;headerlink&quot; title=&quot;赋值与局部状态&quot;&gt;&lt;/a&gt;赋值与局部状态&lt;/h3&gt;&lt;p&gt;假定开始账户里有100元钱，在不断使用withdraw的过程中可以得到以下响应序列：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;withdraw(&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 75&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;withdraw(&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 50&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;withdraw(&lt;span class=&quot;number&quot;&gt;60&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;//余额不足&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到每次执行withdraw的结果不同，我们用一个变量balance去表示账户里的现金余额&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; balance = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;withdraw&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;amount&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(amount &amp;gt; balance)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;余额不足&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        balance -= amount;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(balance);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;withdraw(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 50&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;withdraw(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 30&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;withdraw(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 10&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;----------------------------------&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;new_withdraw&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;amount&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; balance = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (amount &amp;gt; balance) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;余额不足&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        balance -= amount;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(balance);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; balance;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;w1 = new_withdraw(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 50&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;w2 = new_withdraw(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 80&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;w3 = new_withdraw(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;// 80&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到w1、w2、w3是各自独立的，互不影响，与所有状态都必须显式地操作和传递额外参数的方式相比，通过引进赋值和将状态隐藏在局部变量中的技术，我们能以一种更模块化的方式构造系统。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机基础" scheme="https://hqiwen.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统构造浅解第一期</title>
    <link href="https://hqiwen.github.io/2018/11/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9E%84%E9%80%A0/"/>
    <id>https://hqiwen.github.io/2018/11/09/计算机系统构造/</id>
    <published>2018-11-09T14:06:32.000Z</published>
    <updated>2018-11-11T11:31:48.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="程序设计的基本元素"><a href="#程序设计的基本元素" class="headerlink" title="程序设计的基本元素"></a>程序设计的基本元素</h2><ol><li><strong>基本表达式</strong>，用于表示语言关心的最简单个体。</li><li><strong>组合的方法</strong>，通过它们可以从简单的东西出发构造出符合的元素。</li><li><strong>抽象的方法</strong>，通过它们可以为复合对象命名，并将它们当做单元去操作。</li></ol><p>在程序设计中，我们需要处理两类要素：过程和数据。数据是一种我们希望去操作的“东西”，而过程就是有关操作这些数据的规则的描述。</p><h2 id="抽象过程"><a href="#抽象过程" class="headerlink" title="抽象过程"></a>抽象过程</h2><h3 id="数据参数化"><a href="#数据参数化" class="headerlink" title="数据参数化"></a>数据参数化</h3><p>如果我们要计算2的平方，你可能会这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">result = <span class="number">2</span>*<span class="number">2</span></div></pre></td></tr></table></figure><p>现在我们要表达一个”平方”的概念，则有如下公式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line">result = square(<span class="number">2</span>);</div></pre></td></tr></table></figure><p>我们提出了一个复合过程<strong>平方</strong>，从只能计算2的平方到任意数的平方，差别在于给了过程一个参数，把<strong>数据参数化</strong>，可以提高抽象性和适用性，下面用平方去定义<strong>平方和</strong>的概念；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">squareSum</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> square(x) + square(y);</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>实例：比如在canvas上绘制多个矩形：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> array = [</div><div class="line">    [<span class="number">1</span>, <span class="number">0</span>],</div><div class="line">    [<span class="number">2</span>, <span class="number">0</span>],</div><div class="line">    [<span class="number">3</span>, <span class="number">0</span>]</div><div class="line">]</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRectangle</span>(<span class="params">rectangleX, rectangleY, width, height</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> rectangle = <span class="keyword">new</span> Graphics();</div><div class="line">    rectangle.lineStyle(<span class="number">2</span>, <span class="number">0xff3300</span>, <span class="number">1</span>);</div><div class="line">    rectangle.drawRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</div><div class="line">    rectangle.endFill();</div><div class="line">    rectangle.x = rectangleX;</div><div class="line">    rectangle.y = rectangleY;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRectangleFormArray</span>(<span class="params">array, width, height</span>) </span>&#123;</div><div class="line">    arr.forEach(<span class="function"><span class="params">arr</span> =&gt;</span> &#123;</div><div class="line">        createRectangle(arr[<span class="number">0</span>], arr[<span class="number">1</span>], width, height);</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">createRectangleFormArray(array, <span class="number">1</span>, <span class="number">1</span>);</div></pre></td></tr></table></figure><h3 id="函数参数化"><a href="#函数参数化" class="headerlink" title="函数参数化"></a>函数参数化</h3><p>由上面可知，函数是对过程的简化，现在我们尝试把一个函数作为一个参数，那么会得到一个<strong>高阶函数</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span> + message)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Hi"</span> + message)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">saySomething</span>(<span class="params"> fn, message</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fn(message);</div><div class="line">&#125;</div><div class="line">saySomething(sayHello, world);</div><div class="line">saySomething(sayHi, world);</div></pre></td></tr></table></figure><p>实例：高阶组件的应用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span>  [count] = useState(<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        &lt;div&gt;</div><div class="line">            &lt;p&gt;you click &#123; count &#125; times&lt;<span class="regexp">/p&gt;</span></div><div class="line"><span class="regexp">        &lt;/</span>div&gt;</div><div class="line">    )</div><div class="line">&#125;</div><div class="line"><span class="comment">//传入一个组件</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNewProp</span>(<span class="params">component, newProp, initValue</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newComponent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">const</span> [newProp, setNewProp] = useState(initValue);</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="keyword">const</span> &#123; ...others &#125; = component.props;</div><div class="line">            &lt;component newProp = &#123; newProp &#125; &#123; ...others &#125; &gt;<span class="xml"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span></div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">addNewProp(count, time, <span class="string">"2018"</span>)</div></pre></td></tr></table></figure><h2 id="抽象数据"><a href="#抽象数据" class="headerlink" title="抽象数据"></a>抽象数据</h2><p>现在我们要完成有理数的计算，就要<strong>有理数</strong>这个概念，下面构造有理数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">num1, num2</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> num2 === <span class="number">0</span> ? num1 : gcd(num2, num1 % num2);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRat</span>(<span class="params">numer, denom</span>) </span>&#123;</div><div class="line">    <span class="comment">//化约，numer 分子，denom 分母</span></div><div class="line">    <span class="keyword">let</span> gcd_number = gcd(numer, denom);</div><div class="line">    numer = numer / gcd_number;</div><div class="line">    denom = denom / gcd_number;</div><div class="line">    <span class="keyword">this</span>.numer = numer;</div><div class="line">    <span class="keyword">this</span>.denom = denom;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addRat</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> numer = x.numer * y.denom + y.numer * x.denom;</div><div class="line">    <span class="keyword">let</span> denom = x.denom * y.denom;</div><div class="line">    <span class="keyword">return</span> makeRat(numer, denom);</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> makeRat(<span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="keyword">let</span> y = <span class="keyword">new</span> makeRat(<span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure><p>转换成class写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rat</span></span>&#123;</div><div class="line">    construct(numer, denom) &#123;</div><div class="line">        <span class="keyword">let</span> gcd_number = gcd(numer, denom);</div><div class="line">        numer = numer / gcd_number;</div><div class="line">        denom = denom / gcd_number;</div><div class="line">        <span class="keyword">this</span>.numer = numer;</div><div class="line">        <span class="keyword">this</span>.denom = denom;</div><div class="line">    &#125;</div><div class="line">    addRat(x, y) &#123;</div><div class="line">        <span class="keyword">let</span> numer = x.numer * y.denom + y.numer * x.denom;</div><div class="line">        <span class="keyword">let</span> denom = x.denom * y.denom;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Rat(numer, denom);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在我们可以轻松地完成对有理数的操作，从对整数的操作中释放出来，通过<strong>构造有理数</strong>这个概念，为整数提供了一份抽象，我们得以<strong>在有理数之上操作整数</strong>。</p><p>实例：react Element的构造,封装真实DOM的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ReactElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, key, ref, props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> element = &#123;</div><div class="line">    type: type,</div><div class="line">    key: key,</div><div class="line">    ref: ref,</div><div class="line">    props: props,</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> element;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>) </span>&#123;</div><div class="line">  <span class="comment">//some code</span></div><div class="line">  <span class="keyword">return</span> ReactElement(</div><div class="line">    type,</div><div class="line">    key,</div><div class="line">    ref,</div><div class="line">    props,</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> component = <span class="function"><span class="params">()</span> =&gt;</span> (</div><div class="line">    &lt;div&gt;</div><div class="line">        &lt;p&gt;Are you sure?<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></div><div class="line">        &lt;Button color=<span class="string">"blue"</span>&gt;Cancel&lt;<span class="regexp">/Button&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>div&gt;</div><div class="line">)</div><div class="line"><span class="keyword">const</span> component = <span class="function"><span class="keyword">function</span> <span class="title">buildComponent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> React.createElement(</div><div class="line">        <span class="string">"div"</span>,</div><div class="line">        <span class="literal">null</span>,</div><div class="line">        React.createElement(</div><div class="line">            <span class="string">"p"</span>,</div><div class="line">            <span class="literal">null</span>,</div><div class="line">            <span class="string">'Are you sure?'</span></div><div class="line">        ),</div><div class="line">        React.createElement(</div><div class="line">            Button,</div><div class="line">            &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;,</div><div class="line">            <span class="string">"Cancel"</span></div><div class="line">        )</div><div class="line">    )</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;程序设计的基本元素&quot;&gt;&lt;a href=&quot;#程序设计的基本元素&quot; class=&quot;headerlink&quot; title=&quot;程序设计的基本元素&quot;&gt;&lt;/a&gt;程序设计的基本元素&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;基本表达式&lt;/strong&gt;，用于表示语言关心的最简单个体。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合的方法&lt;/strong&gt;，通过它们可以从简单的东西出发构造出符合的元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象的方法&lt;/strong&gt;，通过它们可以为复合对象命名，并将它们当做单元去操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在程序设计中，我们需要处理两类要素：过程和数据。数据是一种我们希望去操作的“东西”，而过程就是有关操作这些数据的规则的描述。&lt;/p&gt;
&lt;h2 id=&quot;抽象过程&quot;&gt;&lt;a href=&quot;#抽象过程&quot; class=&quot;headerlink&quot; title=&quot;抽象过程&quot;&gt;&lt;/a&gt;抽象过程&lt;/h2&gt;&lt;h3 id=&quot;数据参数化&quot;&gt;&lt;a href=&quot;#数据参数化&quot; class=&quot;headerlink&quot; title=&quot;数据参数化&quot;&gt;&lt;/a&gt;数据参数化&lt;/h3&gt;&lt;p&gt;如果我们要计算2的平方，你可能会这样写：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;result = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;现在我们要表达一个”平方”的概念，则有如下公式：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;square&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x * x;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;result = square(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们提出了一个复合过程&lt;strong&gt;平方&lt;/strong&gt;，从只能计算2的平方到任意数的平方，差别在于给了过程一个参数，把&lt;strong&gt;数据参数化&lt;/strong&gt;，可以提高抽象性和适用性，下面用平方去定义&lt;strong&gt;平方和&lt;/strong&gt;的概念；&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;squareSum&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; square(x) + square(y);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机基础" scheme="https://hqiwen.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>精读前后端渲染之争</title>
    <link href="https://hqiwen.github.io/2018/11/09/%E5%89%8D%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93%E5%AF%B9%E6%AF%94/"/>
    <id>https://hqiwen.github.io/2018/11/09/前后端渲染对比/</id>
    <published>2018-11-09T13:00:32.244Z</published>
    <updated>2018-11-09T13:00:32.244Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自<a href="https://medium.freecodecamp.com/heres-why-client-side-rendering-won-46a349fadb52" target="_blank" rel="external">Here’s why Client-side Rendering Won</a>,同时<a href="https://github.com/camsong/blog/issues/8" target="_blank" rel="external">中文翻译地址</a>，如果想获得更好的阅读体验，请阅读原文</p></blockquote><p>1 引言</p><p>我为什么要选这篇文章呢？</p><img src="/2018/11/09/前后端渲染对比/ca1b6618-2209-11e7-99ae-c2a75ad3dabb.png" alt="ca1b6618-2209-11e7-99ae-c2a75ad3dabb.png" title=""><p>十年前，几乎所有网站都使用 ASP、Java、PHP 这类做后端渲染，但后来随着 jQuery、Angular、React、Vue 等 JS 框架的崛起，开始转向了前端渲染。从 2014 年起又开始流行了同构渲染，号称是未来，集成了前后端渲染的优点，但转眼间三年过去了，很多当时壮心满满的框架（rendr、Lazo）从先驱变成了先烈。同构到底是不是未来？自己的项目该如何选型？我想不应该只停留在追求热门和拘泥于固定模式上，忽略了前后端渲染之“争”的“核心点”，关注如何提升“用户体验”。</p><p>原文分析了前端渲染的优势，并没有进行深入探讨。我想以它为切入口来深入探讨一下。</p><p>明确三个概念：「后端渲染」指传统的 ASP、Java 或 PHP 的渲染机制；「前端渲染」指使用 JS 来渲染页面大部分内容，代表是现在流行的 SPA 单页面应用；「同构渲染」指前后端共用 JS，首次渲染时使用 Node.js 来直出 HTML。一般来说同构渲染是介于前后端中的共有部分。<br><a id="more"></a><br>2 内容概要</p><p>前端渲染的优势</p><ul><li>局部刷新。无需每次都进行完整页面请求</li><li>懒加载。如在页面初始时只加载可视区域内的数据，滚动后rp加载其它数据，可以通过 react-lazyload 实现</li><li>富交互。使用 JS 实现各种酷炫效果</li><li>节约服务器成本。省电省钱，JS 支持 CDN 部署，且部署极其简单，只需要服务器支持静态文件即可</li><li>天生的关注分离设计。服务器来访问数据库提供接口，JS 只关注数据获取和展现</li><li>JS 一次学习，到处使用。可以用来开发 Web、Serve、Mobile、Desktop 类型的应用</li></ul><img src="/2018/11/09/前后端渲染对比/68747470733a2f2f706963312e7a68696d672e636f6d2f76322d37623034616335636165363466613737343061316466623162663862303963345f622e706e67.png" alt="68747470733a2f2f706963312e7a68696d672e636f6d2f76322d37623034616335636165363466613737343061316466623162663862303963345f622e706e67.png" title=""><p>后端渲染的优势</p><ul><li>服务端渲染不需要先下载一堆 js 和 css 后才能看到页面（首屏性能）</li><li>SEO</li><li>服务端渲染不用关心浏览器兼容性问题（随意浏览器发展，这个优点逐渐消失）</li><li>对于电量不给力的手机或平板，减少在客户端的电量消耗很重要</li><li>以上服务端优势其实只有首屏性能和 SEO 两点比较突出。但现在这两点也慢慢变得微不足道了。React 这类支持同构的框架已经能解决这个问题，尤其是 Next.js 让同构开发变得非常容易。还有静态站点的渲染，但这类应用本身复杂度低，很多前端框架已经能完全囊括。</li></ul><p>3 精读</p><p>前端渲染遇到的问题</p><p>  前端渲染主要面临的问题有两个 SEO、首屏性能。<br>  SEO 很好理解。由于传统的搜索引擎只会从 HTML 中抓取数据，导致前端渲染的页面无法被抓取。前端渲染常使用的 SPA 会把所有 JS 整体打包，无法忽视的问题就是文件太大，导致渲染前等待很长时间。特别是网速差的时候，让用户等待白屏结束并非一个很好的体验。</p><p>同构的优点</p><p>同构恰恰就是为了解决前端渲染遇到的问题才产生的，至 2014 年底伴随着 React 的崛起而被认为是前端框架应具备的一大杀器，以至于当时很多人为了用此特性而放弃 Angular 1 而转向 React。然而近3年过去了，很多产品逐渐从全栈同构的理想化逐渐转到首屏或部分同构。让我们再一次思考同构的优点真是优点吗？</p><ul><li><p>有助于 SEO</p><p>首先确定你的应用是否都要做 SEO，如果是一个后台应用，那么只要首页做一些静态内容宣导就可以了。如果是内容型的网站，那么可以考虑专门做一些页面给搜索引擎</p><p>时到今日，谷歌已经能够可以在爬虫中执行 JS 像浏览器一样理解网页内容，只需要往常一样使用 JS 和 CSS 即可。并且尽量使用新规范，使用 pushstate 来替代以前的 hashstate。不同的搜索引擎的爬虫还不一样，要做一些配置的工作，而且可能要经常关注数据，有波动那么可能就需要更新。第二是该做 sitemap 的还得做。相信未来即使是纯前端渲染的页面，爬虫也能很好的解析。</p></li><li><p>共用前端代码，节省开发时间</p><p>其实同构并没有节省前端的开发量，只是把一部分前端代码拿到服务端执行。而且为了同构还要处处兼容 Node.js 不同的执行环境。有额外成本，这也是后面会具体谈到的。</p></li><li><p>提高首屏性能</p><p>由于 SPA 打包生成的 JS 往往都比较大，会导致页面加载后花费很长的时间来解析，也就造成了白屏问题。服务端渲染可以预先使到数据并渲染成最终 HTML 直接展示，理想情况下能避免白屏问题。在我参考过的一些产品中，很多页面需要获取十几个接口的数据，单是数据获取的时候都会花费数秒钟，这样全部使用同构反而会变慢。</p></li></ul><p>同构并没有想像中那么美</p><ul><li><p>性能</p><p>把原来放在几百万浏览器端的工作拿过来给你几台服务器做，这还是花挺多计算力的。尤其是涉及到图表类需要大量计算的场景。这方面调优，可以参考 walmart的调优策略。</p><p>个性化的缓存是遇到的另外一个问题。可以把每个用户个性化信息缓存到浏览器，这是一个天生的分布式缓存系统。我们有个数据类应用通过在浏览器合理设置缓存，双十一当天节省了 70% 的请求量。试想如果这些缓存全部放到服务器存储，需要的存储空间和计算都是很非常大。</p></li><li><p>不容忽视的服务器端和浏览器环境差异</p><p>前端代码在编写时并没有过多的考虑后端渲染的情景，因此各种 BOM 对象和 DOM API 都是拿来即用。这从客观层面也增加了同构渲染的难度。我们主要遇到了以下几个问题：<br>document 等对象找不到的问题</p></li><li><p>DOM 计算报错的问题</p></li><li><p>前端渲染和服务端渲染内容不一致的问题</p><p>由于前端代码使用的  window  在 node 环境是不存在的，所以要 mock window，其中最重要的是 cookie，userAgent，location。但是由于每个用户访问时是不一样的  window ，那么就意味着你得每次都更新  window 。</p><p>而服务端由于 js require 的 cache 机制，造成前端代码除了具体渲染部分都只会加载一遍。这时候  window  就得不到更新了。所以要引入一个合适的更新机制，比如把读取改成每次用的时候再读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export const isSsr = () =&gt; (</div><div class="line">  !(typeof window !== &apos;undefined&apos; &amp;&amp; window.document &amp;&amp; window.document.createElement &amp;&amp; window.setTimeout)</div><div class="line">  );</div></pre></td></tr></table></figure><p>原因是很多 DOM 计算在 SSR 的时候是无法进行的，涉及到 DOM 计算的的内容不可能做到 SSR 和 CSR 完全一致，这种不一致可能会带来页面的闪动。</p></li><li><p>内存溢出</p><p>前端代码由于浏览器环境刷新一遍内存重置的天然优势，对内存溢出的风险并没有考虑充分。</p><p>比如在 React 的  componentWillMount  里做绑定事件就会发生内存溢出，因为 React 的设计是后端渲染只会运行  componentDidMount  之前的操作，而不会运行  componentWillUnmount方法（一般解绑事件在这里）。</p></li><li><p>异步操作</p><p>前端可以做非常复杂的请求合并和延迟处理，但为了同构，所有这些请求都在预先拿到结果才会渲染。而往往这些请求是有很多依赖条件的，很难调和。纯 React 的方式会把这些数据以埋点的方式打到页面上，前端不再发请求，但仍然再渲染一遍来比对数据。造成的结果是流程复杂，大规模使用成本高。幸运的是 Next.js 解决了这一些，后面会谈到。</p></li></ul><p>总的来说，同构渲染实施难度大，不够优雅，无论在前端还是服务端，都需要额外改造。</p><hr><p>首屏优化</p><p>再回到前端渲染遇到首屏渲染问题，除了同构就没有其它解法了吗？总结以下可以通过以下三步解决</p><ul><li><p>分拆打包</p><p>现在流行的路由库如 react-router 对分拆打包都有很好的支持。可以按照页面对包进行分拆，并在页面切换时加上一些 loading 和 transition 效果。</p></li><li><p>交互优化</p><p>首次渲染的问题可以用更好的交互来解决，先看下 linkedin 的渲染</p><img src="/2018/11/09/前后端渲染对比/68747470733a2f2f696d672e616c6963646e2e636f6d2f7466732f5442314a6a6b5151705858585858536158585858585858585858582d323535342d313430302e706e67.png" alt="68747470733a2f2f696d672e616c6963646e2e636f6d2f7466732f5442314a6a6b5151705858585858536158585858585858585858582d323535342d313430302e706e67.png" title=""><img src="/2018/11/09/前后端渲染对比/68747470733a2f2f696d672e616c6963646e2e636f6d2f7466732f54423169614d4d51705858585858766158585858585858585858582d323535342d313335342e706e67.png" alt="68747470733a2f2f696d672e616c6963646e2e636f6d2f7466732f54423169614d4d51705858585858766158585858585858585858582d323535342d313335342e706e67.png" title=""><p>有什么感受，非常自然，打开渲染并没有白屏，有两段加载动画，第一段像是加载资源，第二段是一个加载占位器，过去我们会用 loading 效果，但过渡性不好。近年流行 Skeleton Screen 效果。其实就是在白屏无法避免的时候，为了解决等待加载过程中白屏或者界面闪烁造成的割裂感带来的解决方案。</p></li><li><p>部分同构</p><p>部分同构可以降低成功同时利用同构的优点，如把核心的部分如菜单通过同构的方式优先渲染出来。我们现在的做法就是使用同构把菜单和页面骨架渲染出来。给用户提示信息，减少无端的等待时间。</p></li></ul><p>相信有了以上三步之后，首屏问题已经能有很大改观。相对来说体验提升和同构不分伯仲，而且相对来说对原来架构破坏性小，入侵性小。是我比较推崇的方案。</p><p>3 总结</p><p>我们赞成客户端渲染是未来的主要方向，服务端则会专注于在数据和业务处理上的优势。但由于日趋复杂的软硬件环境和用户体验更高的追求，也不能只拘泥于完全的客户端渲染。同构渲染看似美好，但以目前的发展程度来看，在大型项目中还不具有足够的应用价值，但不妨碍部分使用来优化首屏性能。做同构之前 ，一定要考虑到浏览器和服务器的环境差异，站在更高层面考虑。</p><p>附：Next.js 体验</p><p><a href="https://github.com/zeit/next.js/" target="_blank" rel="external">Next.js</a> 是时下非常流行的基于 React 的同构开发框架。作者之一就是大名鼎鼎的 Socket.io 的作者 Guillermo Rauch。它有以下几个亮点特别吸引我：</p><ul><li>巧妙地用标准化的解决了请求的问题。同构和页面开发类似，异步是个大难题，异步中难点又在接口请求。Next.js 给组件新增了 getInitialProps 方法来专门处理初始化请求，再也不用手动往页面上塞 DATA 和调用 ReactDOMServer.renderToString</li><li>使用 styled-jsx 解决了 css-in-js 的问题。这种方案虽然不像 styled-component 那样强大，但足够简单，可以说是最小的成本解决了问题</li><li>Fast by default。页面默认拆分文件方式打包，支持Prefetch页面预加载</li><li>全家桶式的的解决方案。简洁清晰的目录结构，这一点 Redux 等框架真应该学一学。不过全家桶的方案比较适合全新项目使用，旧项目使用要评估好成本</li></ul><p>讨论地址是：<a href="https://github.com/camsong/blog/issues/8" target="_blank" rel="external">前后端渲染之争 · Issue #5 · dt-fe/weekly</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文转载自&lt;a href=&quot;https://medium.freecodecamp.com/heres-why-client-side-rendering-won-46a349fadb52&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Here’s why Client-side Rendering Won&lt;/a&gt;,同时&lt;a href=&quot;https://github.com/camsong/blog/issues/8&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中文翻译地址&lt;/a&gt;，如果想获得更好的阅读体验，请阅读原文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1 引言&lt;/p&gt;
&lt;p&gt;我为什么要选这篇文章呢？&lt;/p&gt;
&lt;img src=&quot;/2018/11/09/前后端渲染对比/ca1b6618-2209-11e7-99ae-c2a75ad3dabb.png&quot; alt=&quot;ca1b6618-2209-11e7-99ae-c2a75ad3dabb.png&quot; title=&quot;&quot;&gt;
&lt;p&gt;十年前，几乎所有网站都使用 ASP、Java、PHP 这类做后端渲染，但后来随着 jQuery、Angular、React、Vue 等 JS 框架的崛起，开始转向了前端渲染。从 2014 年起又开始流行了同构渲染，号称是未来，集成了前后端渲染的优点，但转眼间三年过去了，很多当时壮心满满的框架（rendr、Lazo）从先驱变成了先烈。同构到底是不是未来？自己的项目该如何选型？我想不应该只停留在追求热门和拘泥于固定模式上，忽略了前后端渲染之“争”的“核心点”，关注如何提升“用户体验”。&lt;/p&gt;
&lt;p&gt;原文分析了前端渲染的优势，并没有进行深入探讨。我想以它为切入口来深入探讨一下。&lt;/p&gt;
&lt;p&gt;明确三个概念：「后端渲染」指传统的 ASP、Java 或 PHP 的渲染机制；「前端渲染」指使用 JS 来渲染页面大部分内容，代表是现在流行的 SPA 单页面应用；「同构渲染」指前后端共用 JS，首次渲染时使用 Node.js 来直出 HTML。一般来说同构渲染是介于前后端中的共有部分。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="前端渲染 后端渲染" scheme="https://hqiwen.github.io/tags/%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93-%E5%90%8E%E7%AB%AF%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>使用G2重构日历</title>
    <link href="https://hqiwen.github.io/2018/11/09/%E4%BD%BF%E7%94%A8G2%E9%87%8D%E6%9E%84%E6%97%A5%E5%8E%86/"/>
    <id>https://hqiwen.github.io/2018/11/09/使用G2重构日历/</id>
    <published>2018-11-09T12:46:33.000Z</published>
    <updated>2018-11-09T13:03:58.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="G2是什么"><a href="#G2是什么" class="headerlink" title="G2是什么"></a>G2是什么</h2><blockquote><p><a href="https://antv.alipay.com/zh-cn/g2/3.x/tutorial/index.html" target="_blank" rel="external">G2</a>是一套基于可视化编码的图形语法，以数据驱动，具有高度的易用性和扩展性，用户无需关注各种繁琐的实现细节，一条语句即可构建出各种各样的可交互的统计图表。</p></blockquote><p>简单来说G2就是一个可视化JavaScript工具库，把传进去的数据用图表表现出来，但是不同于其他图形库，G2是基于图形语法工作的</p><h2 id="图形语法"><a href="#图形语法" class="headerlink" title="图形语法"></a>图形语法</h2><p>图形语法描述了我们从数据到图表的映射</p><img src="/2018/11/09/使用G2重构日历/dataToGraph.png" alt="从数据到图形的过程" title="从数据到图形的过程"><ol><li>从数据创建变量 data -&gt; variables[set]</li><li>对变量集进行运算,相对比与集合的运算,找到感兴趣的研究变量(cross, blend, nest)</li><li>对要研究的变量进行归一化，定义变量的性质(cat, time)</li><li>对复杂的变量进行统计,并不是所有的变量都要进行统计</li><li>创建几何图形 variable -&gt; graph</li><li>将建立的图形放到坐标系</li><li>对数据进行美学优化(color, point, label)</li><li>得到相应图形<a id="more"></a>下面给一个简单的示例：</li></ol><img src="/2018/11/09/使用G2重构日历/pieChart.png" alt="饼图" title="饼图"><h2 id="重构的简单说明"><a href="#重构的简单说明" class="headerlink" title="重构的简单说明"></a>重构的简单说明</h2><p>数据还是来源于<strong>data.js</strong>，计算方法大致相同，只不过返回的数据有所不同，日历作为一个二维的图表，返回如下数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ret.push(&#123;</div><div class="line">    weekDay: weekDay,</div><div class="line">    weekIndex: weekIndex,</div><div class="line">    date: showDate,</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>横坐标是weekDay，纵坐标是weekIndex，值是date，则有如下图形语法公式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">chart</div><div class="line">    .point()</div><div class="line">    .shape(<span class="string">"square"</span>)</div><div class="line">    .position(<span class="string">"weekDay*weekIndex"</span>)</div><div class="line">    .color(<span class="string">"date"</span>)</div></pre></td></tr></table></figure><p>添加两个辅助元素对事件的监听，用ID进行区分，来切换上下月：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">chart.on(<span class="string">"guide-text:click"</span>, ev =&gt; &#123;</div><div class="line">    <span class="keyword">if</span> (ev.appendInfo.id == <span class="string">"prevMonth"</span>) &#123;</div><div class="line">        <span class="comment">// some code</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ev.appendInfo.id == <span class="string">"nextMonth"</span>) &#123;</div><div class="line">        <span class="comment">// some code</span></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p><a href="https://github.com/hqiwen/datepicker" target="_blank" rel="external">项目地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;G2是什么&quot;&gt;&lt;a href=&quot;#G2是什么&quot; class=&quot;headerlink&quot; title=&quot;G2是什么&quot;&gt;&lt;/a&gt;G2是什么&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://antv.alipay.com/zh-cn/g2/3.x/tutorial/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;G2&lt;/a&gt;是一套基于可视化编码的图形语法，以数据驱动，具有高度的易用性和扩展性，用户无需关注各种繁琐的实现细节，一条语句即可构建出各种各样的可交互的统计图表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说G2就是一个可视化JavaScript工具库，把传进去的数据用图表表现出来，但是不同于其他图形库，G2是基于图形语法工作的&lt;/p&gt;
&lt;h2 id=&quot;图形语法&quot;&gt;&lt;a href=&quot;#图形语法&quot; class=&quot;headerlink&quot; title=&quot;图形语法&quot;&gt;&lt;/a&gt;图形语法&lt;/h2&gt;&lt;p&gt;图形语法描述了我们从数据到图表的映射&lt;/p&gt;
&lt;img src=&quot;/2018/11/09/使用G2重构日历/dataToGraph.png&quot; alt=&quot;从数据到图形的过程&quot; title=&quot;从数据到图形的过程&quot;&gt;
&lt;ol&gt;
&lt;li&gt;从数据创建变量 data -&amp;gt; variables[set]&lt;/li&gt;
&lt;li&gt;对变量集进行运算,相对比与集合的运算,找到感兴趣的研究变量(cross, blend, nest)&lt;/li&gt;
&lt;li&gt;对要研究的变量进行归一化，定义变量的性质(cat, time)&lt;/li&gt;
&lt;li&gt;对复杂的变量进行统计,并不是所有的变量都要进行统计&lt;/li&gt;
&lt;li&gt;创建几何图形 variable -&amp;gt; graph&lt;/li&gt;
&lt;li&gt;将建立的图形放到坐标系&lt;/li&gt;
&lt;li&gt;对数据进行美学优化(color, point, label)&lt;/li&gt;
&lt;li&gt;得到相应图形
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="可视化" scheme="https://hqiwen.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>一个简易的打包器</title>
    <link href="https://hqiwen.github.io/2018/10/23/%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E6%89%93%E5%8C%85%E5%99%A8/"/>
    <id>https://hqiwen.github.io/2018/10/23/一个简易的打包器/</id>
    <published>2018-10-23T03:20:33.000Z</published>
    <updated>2018-10-23T03:33:36.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="依赖解析"><a href="#依赖解析" class="headerlink" title="依赖解析"></a>依赖解析</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> detective = <span class="built_in">require</span>(<span class="string">"detective"</span>);</div><div class="line"><span class="keyword">const</span> requires = detective(source);</div></pre></td></tr></table></figure><p>深度遍历寻找依赖，返回一个依赖数组</p><h2 id="源码比较简单，主要由三个函数构成"><a href="#源码比较简单，主要由三个函数构成" class="headerlink" title="源码比较简单，主要由三个函数构成"></a>源码比较简单，主要由三个函数构成</h2><h3 id="createModuleObject"><a href="#createModuleObject" class="headerlink" title="createModuleObject()"></a>createModuleObject()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createModuleObject</span>(<span class="params">filePath</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> source = fs.readFileSync(filePath, <span class="string">"utf-8"</span>);</div><div class="line">  <span class="keyword">const</span> requires = detective(source);</div><div class="line">  <span class="keyword">const</span> id = ID++;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    id,</div><div class="line">    filePath,</div><div class="line">    source,</div><div class="line">    requires</div><div class="line">  &#125;;</div></pre></td></tr></table></figure><p> 从目录信息构造需要的模块信息,传入一个文件path路径，返回一个而文件模块对象ModuleObject</p><h3 id="getModules"><a href="#getModules" class="headerlink" title="getModules()"></a>getModules()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getModules</span>(<span class="params">entry</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> rootModule = createModuleObject(entry);</div><div class="line">  <span class="keyword">const</span> modules = [rootModule];</div><div class="line">  <span class="comment">//遍历依赖，把所有引用文件变成模块对象</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">module</span> <span class="keyword">of</span> modules) &#123;</div><div class="line">    <span class="built_in">module</span>.map = &#123;&#125;;</div><div class="line">    <span class="built_in">module</span>.requires.forEach(<span class="function"><span class="params">dependency</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">const</span> basedir = path.dirname(<span class="built_in">module</span>.filePath);</div><div class="line">      <span class="keyword">const</span> dependencyPath = resolve(dependency, &#123; basedir &#125;);</div><div class="line">      <span class="keyword">const</span> dependencyObject = createModuleObject(dependencyPath);</div><div class="line"></div><div class="line">      <span class="built_in">module</span>.map[dependency] = dependencyObject.id;</div><div class="line">      modules.push(dependencyObject);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> modules;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>  获取所有的模块信息，传入一个入口文件path路径，作为根路径，调用createModuleObject()生成模块对象，遍历根路径的依赖，可以把所有引用文件变成模块对象，返回一个所有文件对象模块的数组，根据ID来调用</p><h3 id="pack"><a href="#pack" class="headerlink" title="pack()"></a>pack()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pack</span>(<span class="params">modules</span>) </span>&#123;</div><div class="line">  <span class="comment">//暴露模块IP和依赖</span></div><div class="line">  <span class="keyword">const</span> modulesSource = modules.map(<span class="function"><span class="params">module</span> =&gt;</span> </div><div class="line">      <span class="string">`<span class="subst">$&#123;<span class="built_in">module</span>.id&#125;</span>:&#123;</span></div><div class="line"><span class="string">            factory:(module , require) &#123;</span></div><div class="line"><span class="string">                <span class="subst">$&#123;<span class="built_in">module</span>.source&#125;</span></span></div><div class="line"><span class="string">            &#125;,</span></div><div class="line"><span class="string">            map:<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(<span class="built_in">module</span>.map)&#125;</span></span></div><div class="line"><span class="string">        &#125;`</span>).join();</div><div class="line">  <span class="comment">//返回一个立即执行的函数</span></div><div class="line">  <span class="keyword">return</span> <span class="string">`(modules =&gt; &#123;</span></div><div class="line"><span class="string">        const require = id =&gt; &#123;</span></div><div class="line"><span class="string">            const &#123; factory, map &#125; = modules[id]</span></div><div class="line"><span class="string">            const localRequire = name =&gt; require(map(name))</span></div><div class="line"><span class="string">            const module = &#123; exports: &#123;&#125; &#125;</span></div><div class="line"><span class="string">            factory(module, localRequire)</span></div><div class="line"><span class="string">            return module.exports</span></div><div class="line"><span class="string">        &#125;</span></div><div class="line"><span class="string">        require(0)</span></div><div class="line"><span class="string">  &#125;)(&#123; <span class="subst">$&#123; modulesSource &#125;</span>)`</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>  传入一个Modules[]数组，通过工厂方式构造一个require()函数，把文件模块的ID和依赖暴露出来，方便require的调用，最后调用require(0),调用跟模块，返回一个立即执行的函数</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">---npm install---</div><div class="line"></div><div class="line"><span class="keyword">const</span> pack = <span class="built_in">require</span>(<span class="string">"../bundle"</span>);</div><div class="line"><span class="keyword">const</span> fileWebpack = pack(path);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;依赖解析&quot;&gt;&lt;a href=&quot;#依赖解析&quot; class=&quot;headerlink&quot; title=&quot;依赖解析&quot;&gt;&lt;/a&gt;依赖解析&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; detective = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;detective&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; requires = detective(source);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;深度遍历寻找依赖，返回一个依赖数组&lt;/p&gt;
&lt;h2 id=&quot;源码比较简单，主要由三个函数构成&quot;&gt;&lt;a href=&quot;#源码比较简单，主要由三个函数构成&quot; class=&quot;headerlink&quot; title=&quot;源码比较简单，主要由三个函数构成&quot;&gt;&lt;/a&gt;源码比较简单，主要由三个函数构成&lt;/h2&gt;&lt;h3 id=&quot;createModuleObject&quot;&gt;&lt;a href=&quot;#createModuleObject&quot; class=&quot;headerlink&quot; title=&quot;createModuleObject()&quot;&gt;&lt;/a&gt;createModuleObject()&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;createModuleObject&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;filePath&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; source = fs.readFileSync(filePath, &lt;span class=&quot;string&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; requires = detective(source);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; id = ID++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    id,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    filePath,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    source,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    requires&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 从目录信息构造需要的模块信息,传入一个文件path路径，返回一个而文件模块对象ModuleObject&lt;/p&gt;
&lt;h3 id=&quot;getModules&quot;&gt;&lt;a href=&quot;#getModules&quot; class=&quot;headerlink&quot; title=&quot;getModules()&quot;&gt;&lt;/a&gt;getModules()&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getModules&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;entry&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; rootModule = createModuleObject(entry);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; modules = [rootModule];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//遍历依赖，把所有引用文件变成模块对象&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;of&lt;/span&gt; modules) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.map = &amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.requires.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;dependency&lt;/span&gt; =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; basedir = path.dirname(&lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.filePath);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; dependencyPath = resolve(dependency, &amp;#123; basedir &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; dependencyObject = createModuleObject(dependencyPath);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;module&lt;/span&gt;.map[dependency] = dependencyObject.id;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      modules.push(dependencyObject);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; modules;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="webpack JavaScript" scheme="https://hqiwen.github.io/tags/webpack-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>从数据看vue组件</title>
    <link href="https://hqiwen.github.io/2018/06/09/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%9C%8Bvue%E7%BB%84%E4%BB%B6/"/>
    <id>https://hqiwen.github.io/2018/06/09/从数据看vue组件/</id>
    <published>2018-06-09T00:34:39.000Z</published>
    <updated>2018-06-09T04:53:18.135Z</updated>
    
    <content type="html"><![CDATA[<p>三大前端框架 Vue 、react 和 angular，都提到了一个概念——组件，那么什么是组件——组件（Component）是对数据和方法的简单封装。考虑一个页面，有 UI 的渲染，有状态的改变，有事件的监听。组件正是由这三个方面组成的。现在来看一个简单的组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//绑定class，进行UI渲染</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">v-bind:class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    //传递message值</div><div class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">    //监听click事件</div><div class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"reverseMessage"</span>&gt;</span>逆转消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.container</span>&#123;</div><div class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</div><div class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    el: <span class="string">'#app'</span>,</div><div class="line">    <span class="comment">//页面状态的初始化</span></div><div class="line">    data: &#123;</div><div class="line">        message: <span class="string">'Hello Vue!'</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//事件的处理</span></div><div class="line">    methods: &#123;</div><div class="line">        reverseMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.message = <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>组件关心着三个方面，就是 <strong>UI</strong>，<strong>state</strong>，<strong>event</strong>。vue 用 js 方式注入了样式，状态和事件，当我们编写vue组件时，要考虑这三个方面。样式由css定义，事件是浏览器标准事件，我们主要说说状态。</p><h2 id="组件的状态"><a href="#组件的状态" class="headerlink" title="组件的状态"></a>组件的状态</h2><p>每个组件都可以有自己的状态，从根组件到叶子组件，形成了一个组件树。父组件通过 Prop 向子组件传递数据，同时子组件本身还维持自身的状态。</p><h3 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h3><p>如果一个组件的状态完全由父组件prop传入，那么这个组件就叫做受控组件，又称纯组件。我们把上面的例子改成受控组件，省略css。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span> <span class="attr">v-bind:class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">:message</span> = <span class="string">"message"</span> @<span class="attr">reverse_message</span>=<span class="string">"reverse_message"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</div><div class="line">    el: <span class="string">'#app'</span>,</div><div class="line">    data: &#123;</div><div class="line">        message: <span class="string">'Hello Vue!'</span></div><div class="line">    &#125;</div><div class="line">    components: &#123;</div><div class="line">        <span class="string">'child'</span>: child,</div><div class="line">    &#125;</div><div class="line">    methods: &#123;</div><div class="line">        reverse_message: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.message = <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">Vue.component(<span class="string">'child'</span>, &#123;</div><div class="line">    props: [<span class="string">'message'</span>],</div><div class="line">    template: <span class="string">`</span></div><div class="line"><span class="string">            &lt;div&gt;</span></div><div class="line"><span class="string">                &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;p&gt;</span></div><div class="line"><span class="string">                &lt;button @click="$emit('reverse_message')"&gt;逆转消息&lt;/button&gt;</span></div><div class="line"><span class="string">            &lt;/div&gt;</span></div><div class="line"><span class="string">            `</span>,</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>在例子中child是受控组件，父组件不是，可以发现 message 状态的维护就交给了父组件，这样称作 <strong>状态提升</strong>，一直把状态提升到首页，就是全局状态处理的问题，这是 Vuex 引入的原因。受控组件没有副作用，不会改变应用的状态，便于理解和维护，这也是受欢迎的原因。</p><h3 id="组件的组合与slot"><a href="#组件的组合与slot" class="headerlink" title="组件的组合与slot"></a>组件的组合与slot</h3><p>slot 是 父组件提供内容，子组件接受内容。下面给出一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></div><div class="line">  Your Profile</div><div class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--&lt;navigation-link&gt;--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span></span></div><div class="line"><span class="tag">    <span class="attr">v-bind:href</span>=<span class="string">"url"</span></span></div><div class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"nav-link"</span></span></div><div class="line"><span class="tag">&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>认清页面中数据的流动方向，从更高的抽象上理解组件的状态，知道状态提升，理解全局状态——实现状态共享和同步。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三大前端框架 Vue 、react 和 angular，都提到了一个概念——组件，那么什么是组件——组件（Component）是对数据和方法的简单封装。考虑一个页面，有 UI 的渲染，有状态的改变，有事件的监听。组件正是由这三个方面组成的。现在来看一个简单的组件：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//绑定class，进行UI渲染&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;app&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;v-bind:class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;container&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //传递message值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&amp;#123;&amp;#123; message &amp;#125;&amp;#125;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;p&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //监听click事件&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;v-on:click&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;reverseMessage&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;逆转消息&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.container&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;margin&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;attribute&quot;&gt;padding&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="vue" scheme="https://hqiwen.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>日历插件的重构--引入request.js</title>
    <link href="https://hqiwen.github.io/2018/03/30/%E6%97%A5%E5%8E%86%E6%8F%92%E4%BB%B6%E7%9A%84%E9%87%8D%E6%9E%84-%E5%BC%95%E5%85%A5request-js/"/>
    <id>https://hqiwen.github.io/2018/03/30/日历插件的重构-引入request-js/</id>
    <published>2018-03-30T08:59:56.000Z</published>
    <updated>2018-03-30T09:56:08.360Z</updated>
    
    <content type="html"><![CDATA[<p>在项目过程和状态增加的时候，项目的复杂度增加了，如何对项目进行有效的管理？使用模块化，提炼业务代码的逻辑，有利于适应需求的快速变化。作者使用 request.js 对项目进行了简单重构，阅读源码前最好有相应的 request.js 的基础知识，这将帮助你更好的理解源码。</p><h2 id="request-js-介绍"><a href="#request-js-介绍" class="headerlink" title="request.js 介绍"></a>request.js 介绍</h2><p>对于不懂 request.js 的同学，可以参阅<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="external">阮一峰老师的教程</a>,这里介绍了 request.js 的详细用法，本文略带提一下。</p><blockquote><p>定义并引入模块</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//math.js</span></div><div class="line">define([<span class="string">"moduleA"</span>, <span class="string">"moduleB"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">moduleA, moduleB</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> x + y;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// moduleA some code</span></div><div class="line">    <span class="comment">// moduleB some code</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        add: add</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><blockquote><p>加载模块</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">"math"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</div><div class="line">    alert(math.add(<span class="number">1</span>, <span class="number">1</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure><a id="more"></a><h2 id="业务的分析和分离"><a href="#业务的分析和分离" class="headerlink" title="业务的分析和分离"></a>业务的分析和分离</h2><h3 id="data-js-数据分析"><a href="#data-js-数据分析" class="headerlink" title="data.js(数据分析)"></a>data.js(数据分析)</h3><p>项目是日历的编写，那么数据来源是浏览器提供的 date 对象，日历展示的是一个月的数据，通过年月构造函数 getMonthData()来获取一个月的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getMonthData</span>(<span class="params">year, month</span>) </span>&#123;</div><div class="line">        <span class="comment">//new Date</span></div><div class="line">        <span class="comment">//处理格式</span></div><div class="line">        <span class="comment">//返回数据</span></div><div class="line">        <span class="keyword">return</span> &#123; <span class="attr">year</span>: year,</div><div class="line">                month: month,</div><div class="line">                days: [&#123;</div><div class="line">                    month: month,</div><div class="line">                    date: date</div><div class="line">                &#125;]&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span>&#123;</div><div class="line">        getMonthData: getMonthData</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="render-js（展示分析）"><a href="#render-js（展示分析）" class="headerlink" title="render.js（展示分析）"></a>render.js（展示分析）</h3><p>拿到数据并将数据展示出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'data'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="comment">//获取数据</span></div><div class="line">    monthData = data.getMonthData();</div><div class="line">    <span class="comment">//建立DOM结构</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">buildUI</span>(<span class="params">monthdata</span>)</span>&#123;</div><div class="line">        <span class="comment">//some code</span></div><div class="line">        <span class="keyword">return</span> html</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//上下月判断处理</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">direction</span>(<span class="params">dir</span>)</span>&#123;&#125;</div><div class="line">    <span class="comment">//渲染DOM结构</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">dir</span>)</span>&#123;</div><div class="line">        direction(dir)</div><div class="line">        <span class="comment">//some code</span></div><div class="line">        $wrapper.innerHTML = html;</div><div class="line">        <span class="built_in">document</span>.body.appendChild($wrapper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    retrun &#123;</div><div class="line">        render: render</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="event-js（功能分析）"><a href="#event-js（功能分析）" class="headerlink" title="event.js（功能分析）"></a>event.js（功能分析）</h3><ul><li>当点击输入输入框的时候可以开放或者关闭日历</li><li>当点击上一月的按钮时，切换到上一个月的数据</li><li>当点击下一月的按钮时，切换到下一个月的数据</li><li>当点击日历上的数据时，在输入框中显示其日期</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">'render'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">render</span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showInput</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeMonthData</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        render(<span class="string">"prev/next"</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDate</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        showInput: showInput,</div><div class="line">        changeMonthData: changeMonthData,</div><div class="line">        getDate:getDate,</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h3 id="mian-js"><a href="#mian-js" class="headerlink" title="mian.js"></a>mian.js</h3><p>项目的入口，实行项目的初始化，提供可供用户操作的接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">define([<span class="string">"render"</span>,<span class="string">"event"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">render,event</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">//初始渲染</span></div><div class="line">        render.render();</div><div class="line">        <span class="comment">//事件监听与绑定</span></div><div class="line">        $input.addEventListener(<span class="string">"click"</span>, event.showInput, <span class="literal">false</span>);</div><div class="line">        $wrapper.addEventListener(<span class="string">"click"</span>, event.changeMonthData, <span class="literal">false</span>);</div><div class="line">        $wrapper.addEventListener(<span class="string">"click"</span>, event.getDate, <span class="literal">false</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        init: init,</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="模块依赖"><a href="#模块依赖" class="headerlink" title="模块依赖"></a>模块依赖</h2><img src="/2018/03/30/日历插件的重构-引入request-js/模块.png" alt="400 266" title="400 266"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对项目进行重构，简化了业务的逻辑，对模块化的思想有了更加深刻的认识，现代大型项目的构建离不开模块化。比较好的模块化框架有<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="external">common.js</a>,<a href="http://requirejs.org/" target="_blank" rel="external">request.js</a>,<a href="https://seajs.github.io/seajs/docs/" target="_blank" rel="external">sea.js</a>。学会模块化的思维，将帮助我们成长为更好的工程师。</p><p>项目地址<a href="https://github.com/hqiwen/datepicker" target="_blank" rel="external">https://github.com/hqiwen/datepicker</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目过程和状态增加的时候，项目的复杂度增加了，如何对项目进行有效的管理？使用模块化，提炼业务代码的逻辑，有利于适应需求的快速变化。作者使用 request.js 对项目进行了简单重构，阅读源码前最好有相应的 request.js 的基础知识，这将帮助你更好的理解源码。&lt;/p&gt;
&lt;h2 id=&quot;request-js-介绍&quot;&gt;&lt;a href=&quot;#request-js-介绍&quot; class=&quot;headerlink&quot; title=&quot;request.js 介绍&quot;&gt;&lt;/a&gt;request.js 介绍&lt;/h2&gt;&lt;p&gt;对于不懂 request.js 的同学，可以参阅&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/11/require_js.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰老师的教程&lt;/a&gt;,这里介绍了 request.js 的详细用法，本文略带提一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义并引入模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//math.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;define([&lt;span class=&quot;string&quot;&gt;&quot;moduleA&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;moduleB&quot;&lt;/span&gt;], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;moduleA, moduleB&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; add = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x + y;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// moduleA some code&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// moduleB some code&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        add: add&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;加载模块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&quot;math&quot;&lt;/span&gt;], &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;math&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    alert(math.add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程" scheme="https://hqiwen.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="request.js" scheme="https://hqiwen.github.io/tags/request-js/"/>
    
  </entry>
  
  <entry>
    <title>麻醉药</title>
    <link href="https://hqiwen.github.io/2018/03/09/%E9%BA%BB%E9%86%89%E8%8D%AF/"/>
    <id>https://hqiwen.github.io/2018/03/09/麻醉药/</id>
    <published>2018-03-09T05:57:20.000Z</published>
    <updated>2018-11-23T09:14:16.340Z</updated>
    
    <content type="html"><![CDATA[<p>麻醉药分为全身麻醉药和局部麻醉药。全麻药是具有麻醉功能，能可逆性抑制中枢神经系统功能，引起暂时性感觉、意识和反射消失的药物。局麻药作用神经系统末梢，能暂时、可逆地阻断神经冲动的产生和传导。</p><img src="/2018/03/09/麻醉药/麻醉.jpg" alt="麻醉.jpg" title=""><h2 id="麻醉四期"><a href="#麻醉四期" class="headerlink" title="麻醉四期"></a>麻醉四期</h2><table><thead><tr><th>麻醉分期</th><th>表现</th></tr></thead><tbody><tr><td>第一期(镇痛期)</td><td>麻醉给药到患者意识完全消失，出现镇痛及健忘的麻醉状态</td></tr><tr><td>第二期(兴奋期)</td><td>感觉和意识消失到外科麻醉期，患者兴奋躁动、呼吸不规则、血压不稳定</td></tr><tr><td>第三期(外科麻醉期)</td><td>患者恢复安静，呼吸和血压平稳</td></tr><tr><td>第四期(延髓麻醉期)</td><td>呼吸停止，血压剧降 </td></tr></tbody></table><a id="more"></a><h2 id="全麻药"><a href="#全麻药" class="headerlink" title="全麻药"></a>全麻药</h2><h3 id="吸入性麻醉药"><a href="#吸入性麻醉药" class="headerlink" title="吸入性麻醉药"></a>吸入性麻醉药</h3><p>吸入性麻醉药是挥发性液体或气体的全麻药，经呼吸道吸入给药，给药后由呼吸道经肺泡吸收，麻醉深度可以通过对吸入气体中的全麻药浓度(分压)进行调控并维持其效应在满足手术需要的浓度。常用药物有麻醉乙醚，氟烷，氧化亚氮(笑气)。</p><ul><li>麻醉乙醚：是经典的麻醉药，为无色澄明易挥发液体，有特异臭味，易燃易爆，易氧化产生毒性，乙醚的诱导期和苏醒期较长，易发生麻醉意外。使用简便，在野外、救灾时很重要。</li><li>氟烷：无色透明液体，麻醉作用快而强，麻醉诱导期短而苏醒快</li><li>笑气：无色味甜无刺激性液态气体，性质稳定，诱导期短而苏醒快</li></ul><h3 id="静脉麻醉药"><a href="#静脉麻醉药" class="headerlink" title="静脉麻醉药"></a>静脉麻醉药</h3><ul><li>硫喷妥钠：超短效的巴比妥类药物，静脉注射后几秒钟即可进入脑组织，麻醉作用迅速，镇痛作用差，肌肉松弛不完全，用于各种短时手术。</li><li>氯胺酮：对体表镇痛作用明显，内脏镇痛作用差，用于短时的体表小手术，如烧伤清创、切痂、植皮等。</li></ul><h2 id="局麻药"><a href="#局麻药" class="headerlink" title="局麻药"></a>局麻药</h2><ul><li>普鲁卡因：毒性小，短效酯类麻醉药，对粘膜的穿透性弱，一般不用于表面麻醉，常局部注射用于浸润麻醉、传导麻醉和蛛网膜下腔麻醉。</li><li>利多卡因：是目前应用最多的局麻药，起效快、作用强而持久，可用于多种形式的局部麻醉，有全能麻醉药之称，用于传导麻醉和硬脑膜外麻醉</li></ul><p>麻醉药多种多样，但都是抑制兴奋在神经纤维上的传导，改变局部的离子变化，引起电位变化，不同的给药的方式也会产生不同的药效。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;麻醉药分为全身麻醉药和局部麻醉药。全麻药是具有麻醉功能，能可逆性抑制中枢神经系统功能，引起暂时性感觉、意识和反射消失的药物。局麻药作用神经系统末梢，能暂时、可逆地阻断神经冲动的产生和传导。&lt;/p&gt;
&lt;img src=&quot;/2018/03/09/麻醉药/麻醉.jpg&quot; alt=&quot;麻醉.jpg&quot; title=&quot;&quot;&gt;
&lt;h2 id=&quot;麻醉四期&quot;&gt;&lt;a href=&quot;#麻醉四期&quot; class=&quot;headerlink&quot; title=&quot;麻醉四期&quot;&gt;&lt;/a&gt;麻醉四期&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;麻醉分期&lt;/th&gt;
&lt;th&gt;表现&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一期(镇痛期)&lt;/td&gt;
&lt;td&gt;麻醉给药到患者意识完全消失，出现镇痛及健忘的麻醉状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二期(兴奋期)&lt;/td&gt;
&lt;td&gt;感觉和意识消失到外科麻醉期，患者兴奋躁动、呼吸不规则、血压不稳定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三期(外科麻醉期)&lt;/td&gt;
&lt;td&gt;患者恢复安静，呼吸和血压平稳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第四期(延髓麻醉期)&lt;/td&gt;
&lt;td&gt;呼吸停止，血压剧降 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://hqiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>肾的功能性利尿</title>
    <link href="https://hqiwen.github.io/2018/03/09/%E8%82%BE%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7%E5%88%A9%E5%B0%BF/"/>
    <id>https://hqiwen.github.io/2018/03/09/肾的功能性利尿/</id>
    <published>2018-03-09T05:55:15.000Z</published>
    <updated>2018-11-23T09:14:10.833Z</updated>
    
    <content type="html"><![CDATA[<p>肾脏是排出$Na^+$、$Cl^-$等电解质和水的重要器官，加速电解质和水的排出，就称为利尿。利尿药主要用于各种原因引起的水肿，如心力衰竭、肾衰竭以及肝硬化，也可用于高血压、肾结石、高血钙等的治疗。</p><img src="/2018/03/09/肾的功能性利尿/U.jpg" alt="U.jpg" title=""><p>常用利尿药可以分为5类：</p><h2 id="碳酸酐酶抑制药：乙酰脞胺"><a href="#碳酸酐酶抑制药：乙酰脞胺" class="headerlink" title="碳酸酐酶抑制药：乙酰脞胺"></a>碳酸酐酶抑制药：乙酰脞胺</h2><p>通过抑制碳酸酐酶的活性而抑制$HCO_3^-$的重吸收，由于离子交换，造成尿中H、$K^+$、水($Na^+$)的排出增多。同时也可抑制房水和脑脊液的分泌，本品利尿作用弱，少用。</p><p>临床用途：青光眼(降低眼内压，抑制房水分泌)、急性高山病<br><a id="more"></a></p><h2 id="脱水药：甘露醇"><a href="#脱水药：甘露醇" class="headerlink" title="脱水药：甘露醇"></a>脱水药：甘露醇</h2><p>静脉注射后提高血浆渗透压，使组织液向血浆转移而产生组织脱水作用，可降低颅内压和眼内压。另一方面，血容量的增加使肾小球滤过率增加，产生利尿作用。</p><h2 id="髓袢利尿药：呋塞米"><a href="#髓袢利尿药：呋塞米" class="headerlink" title="髓袢利尿药：呋塞米"></a>髓袢利尿药：呋塞米</h2><p>抑制髓袢$Na^+$-$K^+$-2$Cl^-$转运，抑制<br>$NaCl$的重吸收，降低肾的稀释与浓缩功能，排出大量接近等渗的尿液，是目前最有效的利尿药。</p><p>临床用途：急性肺水肿和脑水肿、急慢性肾衰竭和加速某些毒物的排出。</p><h2 id="噻嗪类-氢氯噻嗪"><a href="#噻嗪类-氢氯噻嗪" class="headerlink" title="噻嗪类:氢氯噻嗪"></a>噻嗪类:氢氯噻嗪</h2><p>抑制近曲小管$Na^+$-$Cl^-$的转运，抑制$NaCl$的重吸收，产生温和持久的利尿作用。排出$Na^+$使血浆渗透压降低而减轻口渴感。</p><p>临床应用：各种类型的水肿、高血压病、尿崩症</p><h2 id="醛固酮受体拮抗药：螺内酯"><a href="#醛固酮受体拮抗药：螺内酯" class="headerlink" title="醛固酮受体拮抗药：螺内酯"></a>醛固酮受体拮抗药：螺内酯</h2><p>醛固酮与受体结合发挥保$Na^+$排$K^+$的作用，螺内酯是醛固酮的竞争性拮抗药，影响醛固酮的作用，表现出排NA保K的作用，利尿作用弱。</p><p>临床应用：与醛固酮升高有关的水肿(肝硬化、肾病综合征)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>利尿药可以促进$Na^+$、$Cl^-$等电解质和水的排出，可以用于纠正<strong>电解质失衡</strong>和<strong>水失衡</strong>，利尿有助于降低血容量，对心脏做功有较好的预防和保护作用，对肾功能失调的可以延缓肾脏衰竭。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;肾脏是排出$Na^+$、$Cl^-$等电解质和水的重要器官，加速电解质和水的排出，就称为利尿。利尿药主要用于各种原因引起的水肿，如心力衰竭、肾衰竭以及肝硬化，也可用于高血压、肾结石、高血钙等的治疗。&lt;/p&gt;
&lt;img src=&quot;/2018/03/09/肾的功能性利尿/U.jpg&quot; alt=&quot;U.jpg&quot; title=&quot;&quot;&gt;
&lt;p&gt;常用利尿药可以分为5类：&lt;/p&gt;
&lt;h2 id=&quot;碳酸酐酶抑制药：乙酰脞胺&quot;&gt;&lt;a href=&quot;#碳酸酐酶抑制药：乙酰脞胺&quot; class=&quot;headerlink&quot; title=&quot;碳酸酐酶抑制药：乙酰脞胺&quot;&gt;&lt;/a&gt;碳酸酐酶抑制药：乙酰脞胺&lt;/h2&gt;&lt;p&gt;通过抑制碳酸酐酶的活性而抑制$HCO_3^-$的重吸收，由于离子交换，造成尿中H、$K^+$、水($Na^+$)的排出增多。同时也可抑制房水和脑脊液的分泌，本品利尿作用弱，少用。&lt;/p&gt;
&lt;p&gt;临床用途：青光眼(降低眼内压，抑制房水分泌)、急性高山病&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://hqiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>肾的内分泌药理</title>
    <link href="https://hqiwen.github.io/2018/03/09/%E8%82%BE%E7%9A%84%E5%86%85%E5%88%86%E6%B3%8C%E8%8D%AF%E7%90%86/"/>
    <id>https://hqiwen.github.io/2018/03/09/肾的内分泌药理/</id>
    <published>2018-03-09T05:39:25.000Z</published>
    <updated>2018-11-23T09:14:04.139Z</updated>
    
    <content type="html"><![CDATA[<p>肾脏是人体的过滤和排泄废物的器官，有保留$Na^{+}$排出$K^{+}$分泌$H^{+}$的作用，同时可以控制尿量来维持血容量，与心血管系统的功能密切相关。</p><p>肾脏可以分泌肾素，肾素使血管紧张素原转化成血管紧张素1（Ang1），血管紧张素1（Ang1）可以在血管紧张素转化酶（ACE）的作用下转化成血管紧张素2（Ang2）。Ang2有两个受体$AT<em>{1}$<br>和<br>$AT</em>{2}$,$AT<em>{1}$受体激动产生<strong>收缩血管</strong>，促进醛固酮的释放，增加血容量，<strong>升高血压</strong>等作用，还有生长激素样作用，可以<strong>促进心肌肥大</strong>，$AT</em>{2}$受体激活缓激肽受体和NO合酶，产生NO，<strong>舒张血管</strong>，<strong>降低血压</strong>，促进细胞凋亡。<br><a id="more"></a><br><img src="/2018/03/09/肾的内分泌药理/ACE.jpg" alt="ACE.jpg" title=""></p><ul><li>ACE抑制药:卡托普利<ul><li>药理作用<ul><li>阻止Ang2的生成：取消Ang2的收缩血管、刺激醛固酮释放、增加血容量、升高血压与促进心肌肥大，有利于高血压、心力衰竭和心血管的重构</li><li>保存缓激肽的活性：缓激肽激活受体，使NO和PGI2（前列腺素）生成增加，而NO和PGI2都可以舒张血管、降低血压、抗血小板聚集、抗心肌细胞肥大增生</li><li>增敏胰岛素受体：增加糖尿病和高血压患者对胰岛素的敏感性</li></ul></li><li>临床应用<ul><li>高血压、充血性心力衰竭、心肌梗死和糖尿病性肾病</li></ul></li><li>不良反应<ul><li>首剂低血压：口服吸收快、生物利用度高的ACE抑制药，出现首剂低血压</li><li><strong>咳嗽</strong>：ACE抑制药使缓激肽和PG在肺内积蓄</li><li><strong>肾功能损伤</strong>：在肾动脉阻塞或肾动脉硬化的患者，本身产生Ang2收缩出球小动脉维持灌注压，ACE抑制药能扩张出球小动脉，降低肾滤过率，削弱肾功能</li><li>血管神经性水肿：常发生于面部，与扩张血管液体渗出有关</li></ul></li></ul></li></ul><img src="/2018/03/09/肾的内分泌药理/AT.gif" alt="AT.gif" title=""><ul><li><p>$AT_{1}$拮抗药：氯沙坦</p><ul><li><p>Ang2激活$AT_{2}$受体，激活缓激肽——NO途径，产生舒张血压、抑制心血管重构等作用，有益于高血压和心力衰竭的治疗</p></li><li><p>不良反应：由于肾素反馈性升高，激活交感神经，产生收缩血管和舒张支气管的作用，故<strong>没有咳嗽和水肿</strong>等不良反应，其余则与ACE抑制药一样</p></li></ul></li></ul><p>对肾脏的内分泌的影响，都可以产生<strong>舒张血管</strong>和<strong>抑制心血管重构</strong>的作用，用于<strong>高血压</strong>的和<strong>心力衰竭</strong>的治疗</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;肾脏是人体的过滤和排泄废物的器官，有保留$Na^{+}$排出$K^{+}$分泌$H^{+}$的作用，同时可以控制尿量来维持血容量，与心血管系统的功能密切相关。&lt;/p&gt;
&lt;p&gt;肾脏可以分泌肾素，肾素使血管紧张素原转化成血管紧张素1（Ang1），血管紧张素1（Ang1）可以在血管紧张素转化酶（ACE）的作用下转化成血管紧张素2（Ang2）。Ang2有两个受体$AT&lt;em&gt;{1}$&lt;br&gt;和&lt;br&gt;$AT&lt;/em&gt;{2}$,$AT&lt;em&gt;{1}$受体激动产生&lt;strong&gt;收缩血管&lt;/strong&gt;，促进醛固酮的释放，增加血容量，&lt;strong&gt;升高血压&lt;/strong&gt;等作用，还有生长激素样作用，可以&lt;strong&gt;促进心肌肥大&lt;/strong&gt;，$AT&lt;/em&gt;{2}$受体激活缓激肽受体和NO合酶，产生NO，&lt;strong&gt;舒张血管&lt;/strong&gt;，&lt;strong&gt;降低血压&lt;/strong&gt;，促进细胞凋亡。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://hqiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>肾上腺素受体的阻断作用</title>
    <link href="https://hqiwen.github.io/2017/12/29/%E8%82%BE%E4%B8%8A%E8%85%BA%E7%B4%A0%E5%8F%97%E4%BD%93%E7%9A%84%E9%98%BB%E6%96%AD%E4%BD%9C%E7%94%A8/"/>
    <id>https://hqiwen.github.io/2017/12/29/肾上腺素受体的阻断作用/</id>
    <published>2017-12-29T03:10:52.000Z</published>
    <updated>2018-11-23T09:13:57.739Z</updated>
    
    <content type="html"><![CDATA[<p>前一章提到了肾上腺素受体的三种激动作用，与之对应存在三种阻断药：α受体阻断药、β受体阻断药以及 α、β受体阻断药。</p><h2 id="α受体阻断药：酚妥拉明"><a href="#α受体阻断药：酚妥拉明" class="headerlink" title="α受体阻断药：酚妥拉明"></a>α受体阻断药：酚妥拉明</h2><ul><li>血管：酚妥拉明具有阻断血管平滑肌α受体和直接<strong>扩张血管</strong>作用。</li><li>心脏：酚妥拉明可<strong>兴奋心脏</strong>，使心脏收缩力增强，心率加快，心输出量增加，与阻断α受体，β受体反馈性增加有关，β受体可对心脏产生正性做作用。</li><li>酚妥拉明可引起皮肤潮红。</li></ul><p>临床应用：治疗外周血管痉挛性疾病，<strong>顽固性充血性心力衰竭</strong>和<strong>急性心肌梗死</strong>，<strong>抗休克</strong>，药物引起的高血压。<br><a id="more"></a></p><h2 id="β受体阻断药：普萘诺尔（心得安）"><a href="#β受体阻断药：普萘诺尔（心得安）" class="headerlink" title="β受体阻断药：普萘诺尔（心得安）"></a>β受体阻断药：普萘诺尔（心得安）</h2><ul><li>心血管：对心脏<strong>抑制作用</strong>明显，表现为心率减慢、心肌收缩力减弱、心输出量减少。对高血压具有降压作用，但降压机制不明确。</li><li>支气管：β受体阻断药阻断支气管平滑肌的 β2受体，<strong>收缩支气管平滑肌</strong>而增加呼吸道阻力。</li><li>甲状腺：<strong>抑制</strong>甲状腺素T4转变为三碘甲状腺原氨酸T3的过程，有效控制甲亢的症状。</li></ul><p>临床应用：快速型心室失常，心绞痛和心肌梗死，高血压，甲状腺功能亢进。</p><p>到目前为止，我们已经了解传出神经系统的方方面面，回顾一下，中枢神经通过对传出神经对躯体进行控制，通过神经递质发挥相应的作用，对应的效应器有<strong>心脏</strong>，<strong>血管</strong>（循环系统）、胃肠道（消化系统）、<strong>支气管</strong>（呼吸系统）、泌尿系统、腺体和眼睛。其中心血管是我们介绍的重点，在这里简单介绍，希望大家了解一些常见药的药理作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一章提到了肾上腺素受体的三种激动作用，与之对应存在三种阻断药：α受体阻断药、β受体阻断药以及 α、β受体阻断药。&lt;/p&gt;
&lt;h2 id=&quot;α受体阻断药：酚妥拉明&quot;&gt;&lt;a href=&quot;#α受体阻断药：酚妥拉明&quot; class=&quot;headerlink&quot; title=&quot;α受体阻断药：酚妥拉明&quot;&gt;&lt;/a&gt;α受体阻断药：酚妥拉明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;血管：酚妥拉明具有阻断血管平滑肌α受体和直接&lt;strong&gt;扩张血管&lt;/strong&gt;作用。&lt;/li&gt;
&lt;li&gt;心脏：酚妥拉明可&lt;strong&gt;兴奋心脏&lt;/strong&gt;，使心脏收缩力增强，心率加快，心输出量增加，与阻断α受体，β受体反馈性增加有关，β受体可对心脏产生正性做作用。&lt;/li&gt;
&lt;li&gt;酚妥拉明可引起皮肤潮红。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;临床应用：治疗外周血管痉挛性疾病，&lt;strong&gt;顽固性充血性心力衰竭&lt;/strong&gt;和&lt;strong&gt;急性心肌梗死&lt;/strong&gt;，&lt;strong&gt;抗休克&lt;/strong&gt;，药物引起的高血压。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://hqiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="肾上腺素 阻断作用" scheme="https://hqiwen.github.io/tags/%E8%82%BE%E4%B8%8A%E8%85%BA%E7%B4%A0-%E9%98%BB%E6%96%AD%E4%BD%9C%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>肾上腺素受体的激动作用</title>
    <link href="https://hqiwen.github.io/2017/12/29/%E8%82%BE%E4%B8%8A%E8%85%BA%E7%B4%A0%E5%8F%97%E4%BD%93%E7%9A%84%E6%BF%80%E5%8A%A8%E4%BD%9C%E7%94%A8/"/>
    <id>https://hqiwen.github.io/2017/12/29/肾上腺素受体的激动作用/</id>
    <published>2017-12-29T03:07:28.000Z</published>
    <updated>2018-11-23T09:13:51.543Z</updated>
    
    <content type="html"><![CDATA[<p>肾上腺素受体分为 α 受体和 β 受体，对肾上腺素受体亚型的选择性，可以分为3类药：α 受体激动药，β 受体激动药和 α、β 受体激动药。</p><h2 id="α受体激动药-去甲肾上腺素"><a href="#α受体激动药-去甲肾上腺素" class="headerlink" title="α受体激动药:去甲肾上腺素"></a>α受体激动药:去甲肾上腺素</h2><ol><li>血管：激动血管α1受体，使<strong>血管收缩</strong>，主要使小动脉和小静脉收缩，皮肤粘膜血管收缩最明显，其次是肾血管。</li><li>心脏：较弱激动心脏β1受体，对心脏产生<strong>正向效应</strong>。</li></ol><a id="more"></a><h2 id="β受体激动药：异丙肾上腺素"><a href="#β受体激动药：异丙肾上腺素" class="headerlink" title="β受体激动药：异丙肾上腺素"></a>β受体激动药：异丙肾上腺素</h2><ol><li>心脏：对心脏β受体有强大的激动作用，产生<strong>正向效应</strong>。</li><li>血管：对血管产生<strong>舒张作用</strong>，主要是激动β受体使骨骼肌血管扩张。</li><li>支气管平滑肌：激动β受体，<strong>舒张</strong>支气管平滑肌。</li><li>代谢：增加糖原分解，<strong>增加</strong>组织耗氧量。</li></ol><h2 id="α、β受体激动药：肾上腺素"><a href="#α、β受体激动药：肾上腺素" class="headerlink" title="α、β受体激动药：肾上腺素"></a>α、β受体激动药：肾上腺素</h2><ol><li>心脏：作用于心脏β受体，加强心肌收缩性，加速传导，加快心率，提高心肌的兴奋性,<strong>正向作用</strong>。</li><li>激动血管平滑肌上α受体，血管收缩，激动β受体，血管舒张。<strong>皮肤黏膜</strong>、<strong>肾</strong>和<strong>胃肠道</strong>α受体占优势，表现为<strong>收缩</strong>；<strong>骨骼肌</strong>和<strong>肝脏</strong>上的β受体占优势，小剂量使其<strong>舒张</strong>。</li><li>平滑肌：激动β受体，舒张支气管，胃肠道平滑肌张力下降，引起排尿困难和尿潴留。</li><li>代谢：肾上腺素提高机体代谢，使耗氧量增加20%到30%。</li></ol><p>综上：三者都对心脏有<strong>正向效应</strong>，但去甲肾上腺素对心脏的兴奋作用较弱，故多用异丙肾上腺素和肾上腺素来抢救<strong>休克</strong>和<strong>心搏骤停</strong>；异丙肾上腺素和肾上腺素可<strong>舒张支气管</strong>，可用于<strong>支气管哮喘</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;肾上腺素受体分为 α 受体和 β 受体，对肾上腺素受体亚型的选择性，可以分为3类药：α 受体激动药，β 受体激动药和 α、β 受体激动药。&lt;/p&gt;
&lt;h2 id=&quot;α受体激动药-去甲肾上腺素&quot;&gt;&lt;a href=&quot;#α受体激动药-去甲肾上腺素&quot; class=&quot;headerlink&quot; title=&quot;α受体激动药:去甲肾上腺素&quot;&gt;&lt;/a&gt;α受体激动药:去甲肾上腺素&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;血管：激动血管α1受体，使&lt;strong&gt;血管收缩&lt;/strong&gt;，主要使小动脉和小静脉收缩，皮肤粘膜血管收缩最明显，其次是肾血管。&lt;/li&gt;
&lt;li&gt;心脏：较弱激动心脏β1受体，对心脏产生&lt;strong&gt;正向效应&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://hqiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="肾上腺素 激动作用" scheme="https://hqiwen.github.io/tags/%E8%82%BE%E4%B8%8A%E8%85%BA%E7%B4%A0-%E6%BF%80%E5%8A%A8%E4%BD%9C%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>乙酰胆碱的阻断作用</title>
    <link href="https://hqiwen.github.io/2017/12/25/%E4%B9%99%E9%85%B0%E8%83%86%E7%A2%B1%E7%9A%84%E9%98%BB%E6%96%AD%E4%BD%9C%E7%94%A8/"/>
    <id>https://hqiwen.github.io/2017/12/25/乙酰胆碱的阻断作用/</id>
    <published>2017-12-25T09:41:53.000Z</published>
    <updated>2018-11-23T09:12:57.775Z</updated>
    
    <content type="html"><![CDATA[<p>胆碱受体分为M受体和N受体，上一节我们知道了M受体激动和N受体激动会产生不同的生理效应，现代药物可以分别阻断不同的受体来产生不同的反应。</p><ul><li>M胆碱受体阻断药：<strong>阿托品</strong>：</li></ul><ol><li><p>心血管系统：</p><p> 1.1 心脏：<strong>小剂量</strong>时ACH受阻负反馈增加，对心脏产生<strong>负性效应</strong>，<strong>大剂量</strong>时ACH完全被阻断，产生<strong>正性效应</strong>，使心率加快，可拮抗房室传导阻滞和心律失常。</p><p> 1.2 血管：阿托品拮抗ACH类药引起的<strong>外周血管扩张</strong>和<strong>血压下降</strong>，大剂量时引起体温升高使散热增加，引起皮肤血管扩张，出现皮肤潮红、温热。</p></li><li><p>平滑肌<br>阿托品对多种内脏平滑肌有<strong>松弛作用</strong>，对过度活动或痉挛的平滑肌作用明显。可以抑制胃肠平滑肌的痉挛，缓解肠胃绞痛，降低尿道和膀胱的张力，接触输尿管张力增高。</p><a id="more"></a></li><li><p>腺体<br>阿托品可以<strong>抑制腺体分泌</strong>，对唾液腺和汗腺最敏感。</p></li><li><p>眼<br>阿托品可以扩瞳，使<strong>眼内压增高</strong>，调节麻痹。</p><p>用途:<strong>接触平滑肌痉挛，抑制腺体分泌，解除缓慢型心律失常，解救有机磷酸酯类中毒（含磷农药）</strong>。</p></li></ol><ul><li><p>N胆碱受体阻断</p><p>  作用于神经肌肉接头的N胆碱受体，产生<strong>肌肉阻滞</strong>作用，只能使骨骼肌麻痹，而不产生麻醉作用，不能使神志和感觉消失，不产生遗忘作用。代表药：司可林，用途：气管插管，气管镜，食管镜，辅助麻醉。</p></li></ul><p>课外拓展：</p><ul><li><a href="https://baike.baidu.com/item/%E9%98%BF%E6%89%98%E5%93%81" target="_blank" rel="external">阿托品</a></li><li><a href="https://baike.baidu.com/item/%E5%8F%B8%E5%8F%AF%E6%9E%97" target="_blank" rel="external">司可林</a></li><li><a href="https://baike.baidu.com/item/%E5%93%8C%E4%BB%91%E8%A5%BF%E5%B9%B3" target="_blank" rel="external">哌仑西平</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;胆碱受体分为M受体和N受体，上一节我们知道了M受体激动和N受体激动会产生不同的生理效应，现代药物可以分别阻断不同的受体来产生不同的反应。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M胆碱受体阻断药：&lt;strong&gt;阿托品&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;心血管系统：&lt;/p&gt;
&lt;p&gt; 1.1 心脏：&lt;strong&gt;小剂量&lt;/strong&gt;时ACH受阻负反馈增加，对心脏产生&lt;strong&gt;负性效应&lt;/strong&gt;，&lt;strong&gt;大剂量&lt;/strong&gt;时ACH完全被阻断，产生&lt;strong&gt;正性效应&lt;/strong&gt;，使心率加快，可拮抗房室传导阻滞和心律失常。&lt;/p&gt;
&lt;p&gt; 1.2 血管：阿托品拮抗ACH类药引起的&lt;strong&gt;外周血管扩张&lt;/strong&gt;和&lt;strong&gt;血压下降&lt;/strong&gt;，大剂量时引起体温升高使散热增加，引起皮肤血管扩张，出现皮肤潮红、温热。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;平滑肌&lt;br&gt;阿托品对多种内脏平滑肌有&lt;strong&gt;松弛作用&lt;/strong&gt;，对过度活动或痉挛的平滑肌作用明显。可以抑制胃肠平滑肌的痉挛，缓解肠胃绞痛，降低尿道和膀胱的张力，接触输尿管张力增高。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://hqiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>乙酰胆碱的促进作用</title>
    <link href="https://hqiwen.github.io/2017/12/25/%E4%B9%99%E9%85%B0%E8%83%86%E7%A2%B1%E7%9A%84%E4%BF%83%E8%BF%9B%E4%BD%9C%E7%94%A8/"/>
    <id>https://hqiwen.github.io/2017/12/25/乙酰胆碱的促进作用/</id>
    <published>2017-12-25T09:39:04.000Z</published>
    <updated>2018-11-23T09:12:47.693Z</updated>
    
    <content type="html"><![CDATA[<p>乙酰胆碱（下面将以ACH代指）是中枢和外周神经系统的内源性神经递质，作用于 M 胆碱受体和 N 胆碱受体。在这一节里，我们重点介绍ACH的作用，ACH性质不稳定，极易被体内的ACH酶所分解，普通作用于各个器官，对各个器官的选择性较差。</p><p>下面逐个介绍ACH的作用：</p><ul><li>M样作用</li></ul><ol><li><p>心血管系统</p><p> 1.1 <strong>舒张血管</strong> ：ACH 作用血管内皮细胞 M3 受体，引起NO的释放，从而是临近平滑肌松弛，小剂量静脉注射可舒张全身血管。</p><p> 1.2 心脏 ： ACH 减弱心肌收缩力，减慢心率，对心脏产生<strong>负性作用</strong>。</p></li><li><p>胃肠道</p><p> ACh 兴奋胃肠道平滑肌，<strong>促进胃肠分泌</strong>，引起恶心、呕吐、腹痛、嗳气</p><a id="more"></a></li><li><p>泌尿道</p><p> ACH 使泌尿道平滑肌蠕动增加，膀胱逼尿肌收缩，导致<strong>膀胱排空</strong>。</p></li><li><p>腺体</p><p> ACH 使泪腺、气管、支气管腺体、唾液腺、消化腺和汗腺分泌增加，<strong>腺体分泌增加</strong>。</p></li><li><p>眼</p><p> ACH 局部滴眼可是瞳孔缩小，睫状肌收缩，<strong>降低眼内压</strong>。</p></li><li><p>支气管</p><p> ACH 使支气管收缩。</p></li></ol><ul><li>N样作用</li></ul><ol><li><p>骨骼肌</p><p> ACH 作用于骨骼肌神经肌肉接头的 N 胆碱受体，可使<strong>骨骼肌收缩</strong>。</p></li></ol><p>枯燥的理论使人犯乏，接下来介绍两种药,将要用到上面的知识。</p><ul><li><p>毛果芸香碱（天然形成的拟胆碱药）</p><blockquote><p>青光眼 ： 进行性视神经乳头凹陷和视力减退为主要特征，并伴有眼内压升高，严重者可以导致失明。</p></blockquote><p><strong>低浓度</strong>的毛果芸香碱滴眼可以用于治疗<strong>青光眼</strong>，用药后使瞳孔缩小，前房角间隙扩大，房水回流通畅，眼内压降低。但高浓度的药物可使患者症状加重。（使用时请谨遵医嘱）</p></li><li><p>新斯的明</p><p>通过抑制ACH酶对 ACH 的分解，发挥ACH的作用，兴奋M、N胆碱受体，兴奋胃肠平滑肌、泌尿道平滑肌和骨骼肌，用于<strong>治疗重症肌无力、腹气胀和尿滞留</strong>。</p></li></ul><p>由于药物多种多样，我们只谈具有代表性的，理解了ACH 的作用，我想大部分这类的药的用法你将了然于胸。不同品种的药，可能药效不一样，但其产生的效应将是一样的。你可能希望读一篇文章而全部弄懂，但是很遗憾地告诉你，这需要你持续不断地跟进前沿知识。希望你有所收获。</p><p>课外拓展：</p><ul><li><a href="https://baike.baidu.com/item/%E6%AF%9B%E6%9E%9C%E8%8A%B8%E9%A6%99%E7%A2%B1" target="_blank" rel="external">毛果芸香碱</a></li><li><a href="https://baike.baidu.com/item/%E6%96%B0%E6%96%AF%E7%9A%84%E6%98%8E" target="_blank" rel="external">新斯的明</a></li><li><a href="https://baike.baidu.com/item/%E9%9D%92%E5%85%89%E7%9C%BC" target="_blank" rel="external">青光眼</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;乙酰胆碱（下面将以ACH代指）是中枢和外周神经系统的内源性神经递质，作用于 M 胆碱受体和 N 胆碱受体。在这一节里，我们重点介绍ACH的作用，ACH性质不稳定，极易被体内的ACH酶所分解，普通作用于各个器官，对各个器官的选择性较差。&lt;/p&gt;
&lt;p&gt;下面逐个介绍ACH的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M样作用&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;心血管系统&lt;/p&gt;
&lt;p&gt; 1.1 &lt;strong&gt;舒张血管&lt;/strong&gt; ：ACH 作用血管内皮细胞 M3 受体，引起NO的释放，从而是临近平滑肌松弛，小剂量静脉注射可舒张全身血管。&lt;/p&gt;
&lt;p&gt; 1.2 心脏 ： ACH 减弱心肌收缩力，减慢心率，对心脏产生&lt;strong&gt;负性作用&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;胃肠道&lt;/p&gt;
&lt;p&gt; ACh 兴奋胃肠道平滑肌，&lt;strong&gt;促进胃肠分泌&lt;/strong&gt;，引起恶心、呕吐、腹痛、嗳气&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://hqiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
